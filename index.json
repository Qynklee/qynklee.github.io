[{"content":"Dưới đây là chall Forensic của SVATTT 2024. Tác giả: bquanman\nChall cho ta 2 file:\nfile process dump file pcapng lưu lượng mạng 1. Kiểm tra file process dump Load vào windbg\nDùng command lm để check các module:\nNhận thấy chỉ có module OneDrive là không có symbols.\nKiểm tra module này, bằng lệnh lmDvmOneDrive\nThấy file thực thi được tải về từ Internet tại Downloads.\nĐịa chỉ trong memory từ 0x7ff620ae0000 đến 0x7ff620afe000\nthực hiện dump đoạn memory này ra file bằng lệnh\n.writemem C:\\TEMP\\OneDrive.dmp 00007ff6`20ae0000 00007ff6`20afe000 Tuy nhiên, báo lỗi không access được dữ liệu tại 0x7ff620afe000\nMình mới thực hiện phân tích lại !analyze -v (không cần thiết)\nSau đó chỉ dump đến 0x7ff620afdf00, bỏ 0x100 bytes cuối đi (đoán)\n.writemem C:\\TEMP\\OneDrive.dmp 00007ff6`20ae0000 00007ff6`20afdf00 Thì dump thành công, Windows Defender check và báo mã độc Havoc.C\nTìm kiếm một hồi về các bài phân tích Havoc C2, mình tìm được 2 link này:\nhttps://github.com/Immersive-Labs-Sec/HavocC2-Forensics\nhttps://www.immersivelabs.com/blog/havoc-c2-framework-a-defensive-operators-guide/\nvà link tàu này:\nhttps://www.51cto.com/article/767998.html\n(Có sẵn PDF cùng folder)\nPhát hiện, cấu trúc KEY_MAKER của Havoc C2 như sau:\nsignatures = { \u0026#39;havoc_key_marker\u0026#39;: \u0026#34;\u0026#34;\u0026#34;rule havoc_aes_marker { strings: $AES_KEY_MARKER = { 00 00 ?? ?? de ad be ef ?? ?? ?? ?? 00 00 00 63 00 00 00 00 } condition: $AES_KEY_MARKER }\u0026#34;\u0026#34;\u0026#34; } Đoạn code detect AES Key và IV, agent ID như sau:\nrules = yara.compile(sources = signatures) .... for offset, rule_name, _name, _value in layer.scan(context = self.context, scanner = yarascan.YaraScanner(rules = rules), sections = vadyarascan.VadYaraScan.get_vad_maps(proc)): if rule_name == \u0026#39;havoc_aes_marker\u0026#39;: # Read 1024 bytes from the layer at the offset and try to parse out some values. raw_data = layer.read(offset, 1024, False) vollog.debug(f\u0026#39;Found AES Key Marker at {hex(offset)} in {process_name}\\n\u0026#39;) vollog.debug(f\u0026#39;Raw Data: {raw_data}\\n\u0026#39;) agent_id = raw_data[8:12].hex() vollog.debug(f\u0026#39;Agent ID: {agent_id}\\n\u0026#39;) aes_key = raw_data[20:52].hex() vollog.debug(f\u0026#39;AES Key: {aes_key}\\n\u0026#39;) aes_iv = raw_data[52:68].hex() vollog.debug(f\u0026#39;AES IV: {aes_iv}\\n\u0026#39;) Có thể thấy AES Key ở offset [20:52], AES IV ở offset [52:68] và Agent ID ở [8:12] tại vị trí tìm ra signature.\nDo đó, mình nhanh chóng thu được key, iv và agent id từ file dump process.\nNhư vậy:\nThu được:\nagent id: 2a c0 84 1e aes key: [20:52] D4 DC 20 98 7E EC 20 02 E0 46 D0 D0 3C BC C2 9A 88 96 44 34 D0 42 90 12 66 BA 98 1C E0 48 98 1E aes iv: [52:68] DC DA C0 90 F6 5E A6 76 FC 72 8E 08 54 66 40 30 Như vậy, mình đã nghĩ đến đây là xong. Mình chỉ mất khoảng 1 tiếng để tìm được đến đây.\nVới bài phân tích vừa rồi, mình đoán sẽ dùng AES decrypt giải mã pcapng để lấy flag.\nTuy nhiên, mọi chuyện không như là mơ.\n2. Xử lý pcapng Kiểm tra pcapng thì chỉ thấy có 2 IP 192.168.240.148 và 192.168.240.147.\nKiểm tra thì chỉ có 2 tcpstream là 0 và 1. là các request đến cổng 443 của IP:148. (attacker)\nNhư vậy, mình cần tìm các requests gửi dữ liệu lên máy chủ, decrypt là lấy được file.\nKhó khăn từ đây (do mình dốt crypto :\u0026lt;)\nKiểm tra sơ sơ thì thấy có vài request POST send data rất lớn.\nĐến đây mình dùng Cyberchef để cố decrypt phần body request nhưng thử với tất cả các thuật toán đều không được, về sau phát hiện ra, Havoc dùng AES CTR mode.\nTuy nhiên, mình vẫn không decrypt được, mình có thử viết code python decrypt cũng không được. Mãi sau, mình mới đọc lại blog 51cto ở trên. Phát hiện phần body có cấu trúc. 20bytes đầu là các giá trị, sau đó là data bị mã hoá.\nData POST lên có cấu trúc như sau:\nDó, lúc này mình mới nhận ra và bắt đầu đi lọc các POST request lớn, có Agent ID và check dữ liệu decrypt.\nMình thu được output command, khẳng định AES Key IV là đúng\nSau đó mình tìm thấy một request có data decrypt có thứ rất quen thuộc, .rels và .xml. Với bản năng của 1 mal analysis, đây là docx mình cần!!!\nMình thu được file docx sau khi chạy word recovery.\nflag 2:\nFlag2: Th3_9r0unD_0b3y5_m3_0e2845b20c93546} Mình bắt đầu hơi hụt hẫng, ủa flag1 đâu, hay trong request vẫn còn. Mình tiếp tục đi decrypt hết các POST data, thậm chí cả data trả về của Havoc C2 server ở IP:148.\nThu được, đoạn text flagpart1 ????\nHay một số data có cấu trúc rất lạ, giống kiểu output của ascii graphic, mà mình không đoán ra ý nghĩa\nData ec0 ec1 do server gửi đến\nNohope flag part 1 :\u0026lt;\nSau đó team có tìm thêm 1 số string trong file OneDrive.exe\nNhưng có vẻ không khả quan lắm.\nCuối cùng mình định tạo lại lab Havoc nhưng đã quá muộn.\nEND GAME lần xxx :((((\nBonus, phần flagpart1, sau khi có WU của tác giả\nĐúng như dự đoán, phần dữ liệu được server gửi đến máy nạn nhân sẽ là 1 object BOF để thực thi,\nHãy quan sát 1 response\nNhư trên, khi server response theo cấu trúc chunk, ta sẽ chỉ quan tâm phần Chunk data.\nphần Chunk Data này sẽ cấu trúc như sau:\n12 bytes đầu (HEADER) | Sau là data Trong HEADER: 2 bytes đầu là Command ID (ở Little edians) =\u0026gt; 0x0A00 = 2560 =\u0026gt; BOF objects Như vậy, decrypt ra sẽ được BOF object.\nTuy nhiên, BOF có signature là bắt đầu bằng bytes\n0x64 0x86 cho 64 bit và 0x4C 0x01 (chữ dt và L.) như ảnh (Phần File Header của NTHeader)\nvới 32bit\nThì trong BOF sẽ như này\nNém vào IDA, phân tích, bấm mặc định, nó sẽ ra được\nNhư vậy, sau khi decrypt BOF bằng AES-CTR mode, ta sẽ phải xoá đi 16bytes đầu để bắt đầu bằng signature BOF.\nKiểm tra hết các BOF, thấy có BOF để thực thi adduser mà không cần dùng command adduser của windows. Đó là user flagpart1\nVì vậy, ta cần đi tìm data của câu lệnh này ở đâu trong BOF object này.\nPhần ảo: Tìm data của BOF object này Theo cấu trúc của havoc C2 BOF, thì các BOF sẽ được tạo sẵn , phần data sẽ nối ở phía sau BOF.\nNhưng các thức chúng được mã hoá AES lại khác nhau\nnhư sau:\nDataChunk = 12bytes HEADER + AES-CTF_Encrypt( 16bytes + BOF object ) + DATA_sau_BOF Mở rộng nhanh, thực tế phần data sau BOF object có 12 bytes là: TaskID, Command,Executable, packed data length nên: DATA_sau_BOF = 12 bytes + AES-CTF_Encrypt( Dữ liệu parametter của BOF ) Nghĩa phần data được mã hoá riêng rẽ chứ không mã hoá chung 1 lần với BOF object.\nMà AES-CTR mode sẽ mã hoá 1bytes thành 1 bytes (tương đương)\nNên chỉ cần lấy độ dài dữ liệu của data chunk post - độ dài BOF objects sau giải mã - 16bytes đầu\nsẽ ra được độ dài phần data bị mã hoá.\nVậy làm sao biết đc BOF object dài bao nhiêu.\nhttps://github.com/HavocFramework/Modules/blob/main/RemoteOps/bin/adduser.x64.o\nCác BOF object là pre-built\nVì vậy, chỉ cần tải file adduser.x64.o cho khớp với BOF trong decrypted data, ta sẽ có được length.\nỞ đây, object BOF Adduser kết thúc ở length 3583, tận cùng là byte 0x00\nVì vậy, với phần data encrypted ở Data chunk\nPhần này cấu trúc như đã nói, toàn bộ Data Chunk có length 3776.\nXoá 12bytes đầu header Được BOF encrypted + data encrypted Tuy nhiên BOF encrypted này có chứa 16bytes đầu là bytes gì đó, trước khi đến được đoạn signature BOF.\nXoá 16bytes đầu của BOF để ra đc signature dt\nXoá tiếp 3583 bytes BOF object\nTa thu được phần data BOF encrypted.\nTuy nhiên, phần data BOF encrypted này cũng có cấu trúc là 12 bytes: TaskID, Command,Executable, packed data length rồi mới đến AES-CTR_Encrypted(Data của BOF)\nXoá 12 bytes đầu\nThực hiện decrypt AES-CTR, Decode UTF-16 LE\nThu được đoạn bytes (153 bytes):\n3b 53 9a a6 93 b6 31 3a cf 25 d6 fa bd b3 ac 98 69 84 ad 7b 25 94 0e ab 5c 3c ec 4b da ea 98 e8 5e b5 c2 5a 8e 37 fa f8 83 eb c4 34 c4 d2 9c e0 67 a6 b5 c0 a3 98 57 3e 29 35 f9 aa 5d 25 1d 44 4d 3e 8d 15 f8 a0 ba 5b 12 a5 55 55 f4 d9 d4 85 b7 f4 1d 6d 8d 7b 4a b9 b0 ca 3e 4d 7b 45 75 4d ff fd 43 74 34 28 b9 d4 3e 14 1b b3 df 7b b6 7a 3c 86 23 7f 82 12 04 a7 5e 62 14 00 00 00 13 d0 c5 8f 13 00 00 00 64 09 97 a7 9e d9 31 8d f7 fd 4d a6 8d be ad 98 0f 84 ad Decrypt bằng AES-CTR và Decode UTF-16 LE:\nVậy flag1 :\nASCIS{C@nt_k3Ep_m3_1n_7hE_9r0uNd_ ","permalink":"https://qynklee.github.io/posts/ascis-2024-forensics-chall-thugs-on-the-boat/","summary":"\u003cp\u003eDưới đây là chall Forensic của SVATTT 2024. Tác giả: bquanman\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20241019215932448\" loading=\"lazy\" src=\"../ascis-2024-forensics-chall-Thugs-on-the-boat_img/image-20241019215932448.png\"\u003e\u003c/p\u003e\n\u003cp\u003eChall cho ta 2 file:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efile process dump\u003c/li\u003e\n\u003cli\u003efile pcapng lưu lượng mạng\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"1-kiểm-tra-file-process-dump\"\u003e1. Kiểm tra file process dump\u003c/h4\u003e\n\u003cp\u003eLoad vào windbg\u003c/p\u003e\n\u003cp\u003eDùng command \u003ccode\u003elm\u003c/code\u003e để check các module:\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20241019220138144\" loading=\"lazy\" src=\"../ascis-2024-forensics-chall-Thugs-on-the-boat_img/image-20241019220138144.png\"\u003e\u003c/p\u003e\n\u003cp\u003eNhận thấy chỉ có module OneDrive là không có symbols.\u003c/p\u003e\n\u003cp\u003eKiểm tra module này, bằng lệnh \u003ccode\u003elmDvmOneDrive\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20241019220239946\" loading=\"lazy\" src=\"../ascis-2024-forensics-chall-Thugs-on-the-boat_img/image-20241019220239946.png\"\u003e\u003c/p\u003e\n\u003cp\u003eThấy file thực thi được tải về từ Internet tại Downloads.\u003c/p\u003e","title":"ASCIS 2024 Forensics Chall: Thugs on the boat"},{"content":"Trong bài này mình sẽ phân tích một mẫu redline stealer được được thực thi thông qua file batch script có mã hash:\n4F1DD4357574C51EC7871212DBC7439C1013561041B5D6B3D5E5CE0DAC996AEB\nĐã quá lâu kể từ khi mình viết report phân tích vì\u0026hellip;.mình khá lười :smile:\nOk, lẹt gô\nStage 1 Đầu tiên với file batch script như sau:\nỞ đây các bạn có thể tấy echo off và line 6 cực kỳ dài. Line 6 bắt đầu bằng :: (tương đương lệnh REM) thì giống như nó đang truyền param là string tại line 6 vào 1 hàm nào đó đúng không. Đến đoạn này thì đầu tiên mình nghĩ đến dùng cmd deobfuscate tuy nhiên tool có vẻ không dùng được với đoạn này. Đến đây mình quyết định tham khảo công nghệ ChatGPT 3.5 (do nghèo) thì nhận được kết quả đoạn script đầu tiên là làm rối đoạn code check AV Defender. :\u0026lt;\nRồi, qua any.run có thể thấy sample này sau khi thực thi sẽ gọi đến cmd với một command khác, rõ ràng hơn, do vậy mình đã bỏ qua đoạn script này mà check luôn đoạn sau.\nCommand đoạn sau như sau: Thực hiện một hồi deobfuscate bằng cơm thì mình được đoạn sau:\nCó thể thấy là đoạn code trên đọc lại file bat ban đầu sau đó thực hiện decrypt và decompress gzip dể tạo 2 object [byte[]] sau đó thực hiện Assembly load 2 object này và thực thi.\nOK vậy là xong stage1.\nVậy thì dump 2 object này ra rồi phân tích thôi, comment đoạn Invoke cuối, save object bằng đoạn:\n$type = $PE_1.GetType() Write-Host \u0026#34;Variable type: $type\u0026#34; $filePath = \u0026#34;C:\\Users\\Inferno\\Desktop\\Malware\\PE_01.bin\u0026#34; [System.IO.File]::WriteAllBytes($filePath, [byte[]]$PE_1) $filePath = \u0026#34;C:\\Users\\Inferno\\Desktop\\Malware\\PE_02.bin\u0026#34; [System.IO.File]::WriteAllBytes($filePath, [byte[]]$PE_2) Stage 2 PE_2 được thực thi trước PE_1 trong code của script nên mình sẽ coi PE_2 trước.\nPE_2 là binary .Net, code cơ bản như sau:\nĐây là đoạn code thực hiện patchi AMSI + ETW của NetLoader để thực hiện load C# binary lên mem và thực thi. PE_2 chỉ có vậy.\nTiếp tục với PE_1\nVới sự đơn giản của PE_2 hứa hẹn PE_1 sẽ khá to và nhiều trò.\nPE_2 có code chính như sau:\nĐoạn code của PE_@ khá ngắn gọn, đơn giản:\nCheck debug Thực hiện Assembyload từ Resource \u0026ldquo;P\u0026rdquo; Đi dump resource P, ta thu được 1 binary C# tiếp theo.\nStage3: Phân tích resource P\nResource P được dump ra đc compress Gzip, extract thu được binary .Net:\ndnspy tiếp, lần này code đã nhiều hơn\nTại entrypoint khởi tạo form1, chỉ thấy các đoạn code tạo giao diện??? Nhìn kỹ chút ngay đầu có hàm Program.WriteLine() đầy nghi hoặc. Check hàm WriteLine thì đó chính là hàm thực thi malicious code:\nĐầu tiên, thực hiện EnvironmentChecker.Check()\nKiểm tra hàm này:\nThực hiện kiểm tra region của máy nạn nhân, nếu region nằm trong list RegionsCountry thì chương trình sẽ tắt:\nprivate static readonly string[] RegionsCountry = new string[] { \u0026#34;Armenia\u0026#34;, \u0026#34;Azerbaijan\u0026#34;, \u0026#34;Belarus\u0026#34;, \u0026#34;Kazakhstan\u0026#34;, \u0026#34;Kyrgyzstan\u0026#34;, \u0026#34;Moldova\u0026#34;, \u0026#34;Tajikistan\u0026#34;, \u0026#34;Uzbekistan\u0026#34;, \u0026#34;Ukraine\u0026#34;, \u0026#34;Russia\u0026#34; }; Ờ thì, list rõ ràng ghê á :v\nTiếp tục, mã độc thực hiện cài đặt RootCert và tìm tất cả shortcut của các trình duyệt và thêm \u0026ldquo;\u0026ndash;proxy-server=\u0026quot;217.65.2.14:3333\u0026quot;\u0026rdquo; để cài đặt proxy cho tất cả các trình duyệt. Điều này sẽ khiến toàn bộ lưu lượng của browser qua Proxy server của hacker, và được decrypt luôn tại có rootcert :\u0026lt; Tệ voãi ò.\nTiếp tục:\nTại hàm này sẽ thực hiện gọi các element của stealer, đồng thời giải mã IP, Port của CC server.\nThuật toán giải mã khá đơn giản:\nChỉ cần base64 \u0026gt; XOR key \u0026gt; base64 lại.\nIP = \u0026ldquo;GSY0Gz4JP1g8HhEILD1HGj8tHw4bJigZPQRPVA==\u0026rdquo;;\nKey = \u0026ldquo;Transcript\u0026rdquo;;\nDùng CyberChef, thu được IP:Port CC như sau:\nCC: 15.235.131.20:39206\nCheck tiếp hàm tạo kết nối đến CC, ta thu được thông tin Authen và rootCert được install vào máy nạn nhân.\nstring text = \u0026#34;0c859af6b9c95799f32f6a1659b784d6\u0026#34;; MessageHeader messageHeader = MessageHeader.CreateHeader(\u0026#34;Authorization\u0026#34;, \u0026#34;ns1\u0026#34;, text); Còn lại là các hàm thực hiện stealer :3 Mình sẽ không nói thêm ở đây. vì mình lười dồi :D\n","permalink":"https://qynklee.github.io/posts/analysis-a-redlinestealer-sample/","summary":"\u003cp\u003eTrong bài này mình sẽ phân tích một mẫu redline stealer được được thực thi thông qua file batch script có mã hash:\u003c/p\u003e\n\u003cp\u003e4F1DD4357574C51EC7871212DBC7439C1013561041B5D6B3D5E5CE0DAC996AEB\u003c/p\u003e\n\u003cp\u003eĐã quá lâu kể từ khi mình viết report phân tích vì\u0026hellip;.mình khá lười :smile:\u003c/p\u003e\n\u003cp\u003eOk, lẹt gô\u003c/p\u003e\n\u003ch3 id=\"stage-1\"\u003eStage 1\u003c/h3\u003e\n\u003cp\u003eĐầu tiên với file batch script như sau:\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240402080214477\" loading=\"lazy\" src=\"../Analysis-a-RedlineStealer-sample_img/image-20240402080214477.png\"\u003e\u003c/p\u003e\n\u003cp\u003eỞ đây các bạn có thể tấy echo off và line 6 cực kỳ dài. Line 6 bắt đầu bằng :: (tương đương lệnh REM) thì giống như nó đang truyền param là string tại line 6 vào 1 hàm nào đó đúng không.\nĐến đoạn này thì đầu tiên mình nghĩ đến dùng cmd deobfuscate tuy nhiên tool có vẻ không dùng được với đoạn này.\nĐến đây mình quyết định tham khảo công nghệ ChatGPT 3.5 (do nghèo) thì nhận được kết quả đoạn script đầu tiên là làm rối đoạn code check AV Defender. :\u0026lt;\u003c/p\u003e","title":"Analysis a RedlineStealer Sample"},{"content":" Giới thiệu Mã độc Emotet là một trong những loại mã độc phổ biến nhất hiện nay, với nhiều biến thể, phiên bản cũ mới khác nhau nhưng nhìn chung mã độc này vẫn sử dụng cách thức lây nhiễm bằng việc spam email bằng những tài liệu được đính kèm macro mã độc.\nTrong báo cáo này, tôi thực hiện phân tích mã độc Emotet E4 xuất hiện vào những ngày đầu tháng 12/2021. Biến thể này có sự thay đổi nhiều hơn hẳn so với mã độc Emotet lần đầu xuất hiện năm 2014 và có sự tương đồng ở một số điểm so với các biến thể E2, E3 đã xuất hiện trong năm 2021.\nMẫu sample được sử dụng trong bài có mã hash:\n67094b85f667eb916255162ddc1e974b093a133ef873be9ee60bf1a7ce030e9e\nTiến hành phân tích Sample là một file word Sample này có cách thực thi là lừa người dùng enable macro để script có thể được thực thi.\nKiểm tra với OleID xác nhận file có chứa macro VBA:\nVới olevba, ta thu được một số kết quả cho thấy file có thể tự thực thi thông qua hàm Document_close() và file có thực hiện thao tác với DLL.\nDump các macro ra với oledump thu được 3 file có liên quan đến macro\nHàm document_close()\nTrong hàm document_close() thực hiện gọi đến 1 hàm user define:\nKiểm tra hàm đó, nhận thấy hàm đã bị obfuscate đi khá nhiều nhưng ta vẫn có thể nhận ra luồng thực hiện của file là thực hiện tạo ra 1 string và gọi 1 hàm\nFind theo tên hàm Sgfrjoifhdolkibhonjduftgi\nTa thấy đây chính là hàm WinExec.\nKiểm tra bằng cách find các string tên các hàm được import từ user32 lib thì ta thấy đây chỉ là các hàm được khai báo mà không sử dụng, chỉ có hàm Sgfrjoifhdolkibhonjduftgi (WinExec) là hàm thực sự được dùng.\nĐọc ngược lại lời gọi đến WinExec để tìm đối số được truyền vào, nhận thấy nó thực hiện việc đọc 1 bảng từ object.\nNhư vậy nghĩa là trong file word còn chứa 1 số bảng đã bị ẩn, object…\nCũng như để tiện cho việc phân tích, thực hiện mở file bằng word để kiểm tra chi tiết hơn.\nTuy nhiên, vba project đã bị đặt mật khẩu\nĐể bypass mật khẩu, ta cần thực hiện patch byte DPB thành DPX trong vbProject.bin và tạo lại mật khẩu để file không bị lỗi.\nSau khi bypass được mật khẩu, ta có thể xem đầy đủ được VB Project này.\nTại đây, thực hiện view object của đối tượng vnbiu…\nWord trỏ đến 1 vùng trắng, thực hiện Unhide, đổi màu, hiện border cho bảng ta thu được:\nKhi đã có đủ các dữ kiện, ta đọc kỹ lại đoạn code ở hàm gọi WinExec\nĐầu tiên, hàm này lấy đoạn text ở Cell(3,1) lưu vào Object.Tag, đặt TextBox4 = “wgjaB “ và đặt TextBox2 là đoạn text ở Cell(2,1) + VBCRLF + đoạn text ở Cell(4,1)\nSau đó thực hiện mở file lưu ở Object.Tag và ghi nội dung ở TextBox2 vào đó.\nSau đó thực hiện WinExec file có tên lưu ở Object.Tag.\nCăn cứ vào đây, ta có thể thấy file bị thực thi đó chính là file “c:\\programdata\\yksds.bat”\nCó nội dung như sau:\nĐây là một đoạn code batch file đã bị obfuscate, mình đi thực hiện deobfuscate nó để xem nó thực sự là gì:\nTiếp tục thực hiện decode Base64 unicode ta thu được\nTại đây script powershell thực hiện tải file vể từ 1 trong các link cho sẵn đến khi nhận được file và lưu thành file .dll tại ProgramData.\nSau đó dùng rundll32.exe để load dll.\nĐến đây ta tiếp tục tải file dll này về để thực hiện phân tích.\nPhân tích dll được tải về File dll được tải về có mã hash:\nabb52688f65425072a2222fe0079879f15672890c1a272193868d3e02e52e760\nDLL chỉ import duy nhất kernel32.dll\nDll export\nKiểm tra các string của file dll phát hiện 2 string khá đáng ngờ là IsProcessorFeaturePresent và GetProcAddress\nPhân tích với IDA\nDll có áp dụng kỹ thuật AntiDebug\nBypass Antidebug và thực hiện debug file, phát hiện mã đọc thực hiện VirtualAlloc một vùng nhớ và memcpy đến vùng nhớ đó. Ngoài ra, với việc chỉ import kernel32.dll khiến rất có thể mã độc sẽ thực hiện LoadLibraryA. Vì vậy, ta đặt breakpoint tại các lệnh call như VirtualAlloc, memcpy, LoadLibraryA để kiểm tra.\nBreakpoint được trigger tại hàm VirtualAlloc.\nTiếp tục trace code ta thu được địa chỉ source và destination khi dll thực hiện memcpy.\nFollow theo địa chỉ source ta thu được một header PE rất quen thuộc\nTại đây, mã độc đang thực hiện load các section của dll tại source lên vùng nhớ tại ở địa chỉ 0x1000000 với Section Alignment là 0x1000.\nThực hiện dump vùng nhớ source bằng 1 script IDAPython nhỏ\nKiểm tra file đã dump ra, đây chính là 1 dll.\nVà lần này, file dll chỉ export duy nhất một hàm là DllRegisterServer. Và không có import bất kỳ Dll nào cũng như không có string nào có nghĩa.\nTiếp tục thực thi debug ta thấy dll gọi đến Entrypoint của dll mà ta vừa dump.\nPhân tích DLL vừa dump Phân tích với IDA ta có thể thấy hàm DllEntrypoint của dll được obfuscate.\nKiểm tra vào các hàm tiếp nhận thấy các hàm đều được obfuscate theo cùng một phương pháp là Control-Flow-Flatenning. Kỹ thuật này biến luồng thực thi nằm trong 1 vòng while(1) và switch case.\nVì vậy để đơn giản hóa việc phân tích ta sẽ chỉ cần bỏ qua hết các group chứa lệnh cmp, mov rồi jmp lại điểm đầu\nThực thi mã độc và ghi lại log với ProcMon và PinTool ta thu được\nDLL quả nhiên có load rất nhiều các dll khác nhau, đồng thời, sau đó tự copy chính mình vào local %AppData%.\nVà thêm khóa Registry để gọi chính mình.\nVới việc mã độc load rất nhiều dll, thực hiện thao tác ghi file, create registry… cho thấy mã độc đã áp dụng một số kỹ thuật của shellcode để có thể gọi được GetProcAddress và LoadLibraryA.\nKỹ thuật phổ biến trong trường hợp này là sử dụng cấu trúc PEB.\nTại đây, tôi sử dụng script IDAPython dưới đây để nhanh chóng tìm ra cấu trúc PEB.\nLập tức ta thu được địa chỉ trỏ đến một hàm\nTrace code theo Xref\nSau khi có được địa chỉ kernel32.dll, mã độc tiếp tục thực hiện việc tính hash string tên dll và tên hàm để thực hiện call function.\nDll thực hiện lấy địa chỉ các API dựa trên hash function:\nSau đó, dll thực hiện call API qua câu lệnh call EAX.\nSau quá trình phân tích, nhận thấy tất cả các hash function được push vào stack và gọi đến hàm STEP_5_GetFuncAddressInDLLImport và call eax để gọi đến hàm đó.\nNhư vậy, hàm STEP_5_ GetFuncAddressInDLLImport chính là chìa khóa để kiểm tra tất cả các API được gọi.\nKiểm tra Xref với hàm này, ta thu được rất nhiều function được gọi đến với các hash khác nhau.\nMột hàm gọi đến hàm STEP_5_GetFuncAddressInDLLImport\nĐi sâu vào phân tích hàm STEP_5_GetFuncAddressinDLLImport này ta tìm thấy hàm hash các string DLL và Function name được truyền vào.\nNgoài ra, cách hash này cũng được dùng để tính hash cho các dll name để tìm đúng mã hash được truyền vào.\nTiếp tục trace code trong hàm STEP_5_GetFuncAddressInDLLImport ta tìm được DLL xor key và function xor key\nDLL XOR key: 0x1BFA6646\nFunc XOR key: 0x3AACD9B2\nĐến đây ta có thể xây dựng lại toàn bộ quá trình tính hash để xác định được các hàm, API được gọi bằng việc brute force toàn bộ các Dll Name và Func Name.\nThử với một func ta thấy thuật toán hash tìm được hoàn toàn chính xác\nĐến đây, với các nguyên liệu đã có là mã hash đã biết, key xor, đầu vào chỉ là tên các dll và các tên hàm được export từ dll.\nThực hiện viết một script Python để lấy toàn bộ các export function từ các dll có liên quan và một script IDAPython để thực hiện xác định chính xác hàm nào, thuộc dll nào được gọi thông qua hàm STEP_5_GetFuncAddressInDLLImport.\nScript trên đây dùng để tạo dữ liệu gồm tên các dll và tên hàm được export.\nĐây là scrip IDAPython có nhiệm vụ kiểm tra tất cả các hàm Xref đến STEP_5_GetFuncAddressInDLLImport và lấy ra 2 giá trị DLL Hash và FuncHash để tìm tên chính xác và đổi tên hàm cho thuận tiện trong quá trình phân tích tiếp theo.\nKết quả sau khi chạy script ta thu được các tên hàm đã rất dễ hiểu hơn nhiều so với ban đầu\nDựa vào các dll được dynamic resolve là: advapi32, bcrypt, kernel32, shell32, shlwapi, userenv, wininet và wtsapi32 có thể thấy mã độc có thực hiện các thao tác đến Registry, thực hiện mã hóa, giải mã, kết nối mạng…\nVới câu hỏi, dll không hề có string khi kiểm tra string, làm cách làm lại có string của dll để thực hiện xor với hash. Tìm kiếm Xref đến hàm mw_kernel32_dll_LoadLibraryW mã ta vừa đổi tên phía trước. Ta thu được\nTa chỉ cần quan tâm đến thanh ghi esi sẽ nhận ra thanh ghi này được push làm tham số khi thực hiện call eax (call LoadLibraryW).\nNhư vậy chứng tỏ, bằng cách nào đó string bản rõ đã được giải mã ở esi.\nTiếp tục trace lên trên thấy: mov esi, eax\nĐiều này khẳng định string bản rõ được giải mã ở hàm call ngay phía trên.\nKiểm tra luồng thực thi của hàm này, ta thu được\nTrong hàm này đã gọi đến hàm HeapAlloc và GetProcessHeap. Điều này chứng tỏ đã có một vùng nhớ heap được tạo ra và rất có thể string bản rõ được giải mã lên heap.\nThực hiện debug hàm này với x64Dbg, ta xác thực việc này. String bản rõ được giải mã trên Heap là UTF-16 và sau khi Load được dll lên mã độc sẽ HeapFree vùng nhớ này ngay sau đó.\nĐể tìm được thuật toán giải mã string, ta đi kiểm tra sâu hơn hàm thực hiện HeapAlloc.\nMay mắn trong hàm này có thực hiện call nhưng chỉ liên quan đến call các API đã được đánh tên từ trước, vì vậy chắc chắn việc giải mã nằm ngay trong hàm này.\nKiểm tra các tham số đầu vào của hàm này, ta thấy hàm này được gọi từ rất nhiều vị trí nhưng đều có điểm chung.\nĐiểm chung đó là trước khi call được hàm này, mã độc sẽ push một offset vào ecx rồi mới thực hiện call.\nDựa vào đây ta có thể nhận định, dữ liệu được đưa vào ecx sau đó là edx rồi mới vào hàm thực hiện Decrypt.\nĐi tiếp vào trong hàm decrypt lúc trước, với edx đang chứa offset dữ liệu bị mã hóa, nó được mov sang esi. Và địa chỉ từ byte thứ 4 trở đi được mov sang edi.\nTừ đây, quá trình decrypt string trong esi và edi.\nCác bước thực hiện như sau:\nĐịa chỉ ban đầu esi Địa chỉ từ byte thứ 4 trở đi ở edi Giá trị eax = 2 lần giá trị ([edi] ^ [esi]) Khởi tạo Heap có độ dài bằng eax. Kết hợp với kết quả debug từ x64dbg phía trước ta xác định, giá trị [edi] ^ [esi] chính là độ dài string ở UTF-8, việc eax = 2 lần độ dài là do đó là string UTF-16.\nTiếp tục trace xuống vòng lặp phía dưới, lúc này EBX chứa địa chỉ vùng nhớ heap vừa được tạo.\nTừ đây ta có thể thấy, giải giải mã diễn ra bằng cách xor với key ở ebx, đây chính là 4 byte đầu của dữ liệu.\nTới đây ta đã có thuật toán mã hóa string và cách giải mã hoàn chỉnh. Dữ liệu về string được lưu có bố cục như sau:\nCác dữ liệu đã được mã hóa được lưu tại đoạn đầu section .text và IDA đã index được các đoạn này.\nThực hiện decrypt hết toàn bộ các dữ liệu này, sử dụng một script IDAPython để find các dword này và thực hiện decrypt, comment các dword này và log lại.\nKết quả thu được\nSau khi decrypt được toàn bộ các string ta có thể nhận ra một số string quan trọng như:\n0x71141000 SHA256\n0x71141020 ObjectLength\n0x71141040 Microsoft Primitive Provider\n0x71141080 ECCPUBLICBLOB\n0x711410b0 AES\n0x711410d0 HASH\n0x711410f0 ECDH_P256\n0x71141120 ECDSA_P256\n0x71141150 KeyDataBlob\nx71141504 POST\n0x71141514 __\u0026ndash;%S\u0026ndash;\n0x71141534 %u.%u.%u.%u\n0x71141564 Cookie: %s=%s__\n0x711415a4 Content-Type: multipart/form-data; boundary=%s__\n0x71141604 \u0026ndash;%S__Content-Disposition: form-data; name=\u0026quot;%S\u0026quot;; filename=\u0026quot;%S\u0026quot;Content-Type: application/octet-stream\n0x71141684 %s%s.dll\n0x711416b4 %s%s.exe\n0x711416e4 DllRegisterServer\n0x71141714 %s\\regsvr32.exe -s \u0026ldquo;%s\u0026rdquo;\n0x71141754 %s\\rundll32.exe \u0026ldquo;%s\u0026rdquo;,DllRegisterServer\n0x71141794 %s\\rundll32.exe \u0026ldquo;%s\u0026rdquo;,DllRegisterServer %s\n0x711417d4 %s%s\n0x71141804 %s\\rundll32.exe \u0026ldquo;%s%s\u0026rdquo;,%s\n0x71141844 DllRegisterServer\n0x71141864 %s%s%x\n0x71141894 SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\n0x711418f4 %s\\rundll32.exe \u0026ldquo;%s%s\u0026rdquo;,%s %s\n0x71141934 %s\\rundll32.exe \u0026ldquo;%s\u0026rdquo;,DllRegisterServer\nDựa vào các string trên ta có thể thấy mã độc còn có mã hóa SHA256, AES và kết nối đến 1 IP, key registry mà mã độc sử dụng để autorun.\nDựa vào các string, các hàm đã recovery ta sẽ tiếp tục trace theo 2 hướng theo các hàm mã hóa từ dll bcrypt, string liên quan đến mã hóa và từ các hàm từ dll wininet.\nTrace theo string IP Format: %u.%u.%u.%u\nTại đây, offset của IP_Format được giải mã và lưu địa chỉ ở EAX, sau đó thực hiện call đến 1 sub_7114FFBA\nTìm theo hash value ta được hàm đó là _snwprintf(), dổi tên hàm lại cho đúng và bắt đầu phân tích hàm đã gọi đến offset IP_Format này.\nCũng giống như các hàm khác của mã độc, hàm này cũng đã bị obfuscate bằng phương pháp Control Flow Flatenning tuy nhiên với số lượng các khối khá ít hoàn toàn có thể phân tích luồng thực thi được.\nTại ngay điểm đầu vào, thực hiện cmp ecx, 0A5ACBAh do vậy thanh ghi ecx chính là thanh ghi dùng để điều khiển luồng thực thi.\nKéo lên trên để xem ecx đã được set giá trị bằng bao nhiêu, có thể thấy ngay đầu hàm, ecx đã được set giá trị\nNhư vậy, ta biết bước đầu tiên, sẽ thực thi khối nào\nTại đây ecx lại được mov một giá trị mới và cứ flow theo giá trị ecx, ta đến bước thứ 2\nTại bước thứ 2, mã độc thực hiện push offset một dword tại .data segment sau đó call đên sub_711602B3()\nKiểm tra trong hàm sub_711602B3() cho thấy hàm thực hiện tạo một vùng nhớ heap sau đó thực hiện một vòng loop rất quen thuộc tương đương như khi đang thực thi decrypt string.\nThực hiện dump dữ liệu ở vị trí này ra và decrypt bằng thuật toán đã dùng với string.\nTa thu được dữ liệu có cấu trúc gồm các giá trị, mỗi cụm 8 byte phân cách nhau bằng byte 0, 1.\nDebug với x64dbg khẳng định điều này, lần này dữ liệu giải mã ra cũng được HeapFree tại bước 6.\nNhư vậy chắc chắn trong hàm này có đoạn sử dụng đến dữ liệu đã decrypt ra. Đặt breakpoint tại vị trí này và thực thi, ta đến đoạn code sau:\nTại đây EDI đang lưu địa chỉ của dữ liệu vừa giải mã trên Heap.\nDebug với x64dbg, string format được giải mã và thực hiện hàm _snwprintf() với các tham số sau:\nKết quả thu được sau khi hàm _snwprintf() được thực thi\nNhư vậy 4 byte đầu trong cấu trúc 8 byte chính là địa chỉ IP.\nSau khi thực hiện giải mã IP ra Buffer, mã độc tiếp tục dùng thanh ghi edi đang trỏ đến dữ liệu đã giải mã trên heap để lấy ra giá trị word big endian tại byte thứ 5 và byte thứ 6. Đây chính là Port.\nTa thu được danh sách các CC Server như sau:\n[\u0026lsquo;172.104.227.98:443\u0026rsquo;, \u0026lsquo;31.207.89.74:8080\u0026rsquo;, \u0026lsquo;46.55.222.11:443\u0026rsquo;, \u0026lsquo;41.76.108.46:8080\u0026rsquo;, \u0026lsquo;103.8.26.103:8080\u0026rsquo;, \u0026lsquo;185.184.25.237:8080\u0026rsquo;, \u0026lsquo;103.8.26.102:8080\u0026rsquo;, \u0026lsquo;203.114.109.124:443\u0026rsquo;, \u0026lsquo;45.118.115.99:8080\u0026rsquo;, \u0026lsquo;178.79.147.66:8080\u0026rsquo;, \u0026lsquo;58.227.42.236:80\u0026rsquo;, \u0026lsquo;45.118.135.203:7080\u0026rsquo;, \u0026lsquo;103.75.201.2:443\u0026rsquo;, \u0026lsquo;195.154.133.20:443\u0026rsquo;, \u0026lsquo;192.254.71.210:443\u0026rsquo;, \u0026lsquo;45.142.114.231:8080\u0026rsquo;, \u0026lsquo;212.237.5.209:443\u0026rsquo;, \u0026lsquo;207.38.84.195:8080\u0026rsquo;, \u0026lsquo;104.251.214.46:8080\u0026rsquo;, \u0026lsquo;212.237.17.99:8080\u0026rsquo;, \u0026lsquo;212.237.56.116:7080\u0026rsquo;, \u0026lsquo;216.158.226.206:443\u0026rsquo;, \u0026lsquo;110.232.117.186:8080\u0026rsquo;, \u0026lsquo;158.69.222.101:443\u0026rsquo;, \u0026lsquo;107.182.225.142:8080\u0026rsquo;, \u0026lsquo;176.104.106.96:8080\u0026rsquo;, \u0026lsquo;81.0.236.90:443\u0026rsquo;, \u0026lsquo;50.116.54.215:443\u0026rsquo;, \u0026lsquo;138.185.72.26:8080\u0026rsquo;, \u0026lsquo;51.68.175.8:8080\u0026rsquo;]\nTiếp tục phân tích theo các string đã thu được có string đặc biệt\n0x71141080 ECCPUBLICBLOB\n0x711410b0 AES\n0x711410d0 HASH\n0x711410f0 ECDH_P256\n0x71141120 ECDSA_P256\n0x71141150 KeyDataBlob\nĐây là các string của mã hóa ECC (Elliptic Curve Cryptography) là một kiểu mã hóa khóa công khai tương tự như RSA với khả năng mã hóa an toàn hơn với khóa ngắn hơn. Trong trường hợp của mã độc là P256 tức key 32bits.\nĐặc biệt hơn mã hóa ở đây chính là ECDH_P256 là thuật toán trao đổi khóa Diffie-Hellman ECC 256bit và ECDSA_P256 là thuật toán chữ ký số ECC 256bit.\nTrong quá trình giải mã các string của mã độc, có 2 string đã bị loại khỏi danh sách để add comment do chứa các byte không phải ký tự ascii tuy nhiên lại bắt đầu bằng “ECS1” và “ECK1”. Trong thư viện bcrypt.h có define:\nNhư vậy 2 string chứa các byte trên là khóa công khai của ECDSA và ECDH p256.\nĐể kiểm tra xem cụm byte trên có cấu trúc như thế nào, thực hiện debug với x64dbg trace code từ DllRegisterServer trở đi, ta đến được hàm call 71AB000D, tại đây thanh ghi ECX và EDX đang là con trỏ trở tới 2 cấu trúc ECS1 và ECK1.\nBên trong hàm sub_71AB000D thực hiện tạo heap và gọi đến sub_71AAE16F() hàm này gọi rất nhiều API đến từ thư viện bcrypt.\nBên trong sub_71AB000D():\nBên trong sub_71AAE16F():\nTiếp tục trace debug vào bên trong ta có thể thấy mã độc call:\nBCryptOpenAlgorithmProvider : ECDH_P256 Microsoft Primitive Provider BcryptGenerateKeyPair BcryptFinalizekeyPair: Handlekey 0x569AC8 BcryptExportKey với tham số ECCPUBLICBLOB. BcryptImportKeyPair BcryptSecretAgreement với Pubkey và PrivKey\npubKey:\nPrvKey\nTiếp tục trace debug qua x64dbg ta có thể thấy ngoài khởi tạo CNG Provider cho trao đổi khóa, mã độc còn khởi tạo CNG cho AES và SHA256. Tiếp tục dump ta sẽ nhận thấy các byte phía sau cảu cụm string ECK1 và ECS1 có cấu trúc như sau: Như vậy ta có thể khôi phục được khóa công khai mà mã độc sử dụng để mã hóa dữ liệu trong quá trình trao đổi key. Khóa thu được là: ","permalink":"https://qynklee.github.io/posts/analysis-a-emotet-malware-sample/","summary":"\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eGiới thiệu\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eMã độc Emotet là một trong những loại mã độc phổ biến nhất hiện nay, với nhiều biến thể, phiên bản cũ mới khác nhau nhưng nhìn chung mã độc này vẫn sử dụng cách thức lây nhiễm bằng việc spam email bằng những tài liệu được đính kèm macro mã độc.\u003c/p\u003e\n\u003cp\u003eTrong báo cáo này, tôi thực hiện phân tích mã độc Emotet E4 xuất hiện vào những ngày đầu tháng 12/2021. Biến thể này có sự thay đổi nhiều hơn hẳn so với mã độc Emotet lần đầu xuất hiện năm 2014 và có sự tương đồng ở một số điểm so với các biến thể E2, E3 đã xuất hiện trong năm 2021.\u003c/p\u003e","title":"Analysis a Emotet Malware Sample"}]