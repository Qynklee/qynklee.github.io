[{"content":"Dưới đây là chall Forensic của SVATTT 2024. Tác giả: bquanman\nChall cho ta 2 file:\nfile process dump file pcapng lưu lượng mạng 1. Kiểm tra file process dump Load vào windbg\nDùng command lm để check các module:\nNhận thấy chỉ có module OneDrive là không có symbols.\nKiểm tra module này, bằng lệnh lmDvmOneDrive\nThấy file thực thi được tải về từ Internet tại Downloads.\nĐịa chỉ trong memory từ 0x7ff620ae0000 đến 0x7ff620afe000\nthực hiện dump đoạn memory này ra file bằng lệnh\n.writemem C:\\TEMP\\OneDrive.dmp 00007ff6`20ae0000 00007ff6`20afe000 Tuy nhiên, báo lỗi không access được dữ liệu tại 0x7ff620afe000\nMình mới thực hiện phân tích lại !analyze -v (không cần thiết)\nSau đó chỉ dump đến 0x7ff620afdf00, bỏ 0x100 bytes cuối đi (đoán)\n.writemem C:\\TEMP\\OneDrive.dmp 00007ff6`20ae0000 00007ff6`20afdf00 Thì dump thành công, Windows Defender check và báo mã độc Havoc.C\nTìm kiếm một hồi về các bài phân tích Havoc C2, mình tìm được 2 link này:\nhttps://github.com/Immersive-Labs-Sec/HavocC2-Forensics\nhttps://www.immersivelabs.com/blog/havoc-c2-framework-a-defensive-operators-guide/\nvà link tàu này:\nhttps://www.51cto.com/article/767998.html\n(Có sẵn PDF cùng folder)\nPhát hiện, cấu trúc KEY_MAKER của Havoc C2 như sau:\nsignatures = { \u0026#39;havoc_key_marker\u0026#39;: \u0026#34;\u0026#34;\u0026#34;rule havoc_aes_marker { strings: $AES_KEY_MARKER = { 00 00 ?? ?? de ad be ef ?? ?? ?? ?? 00 00 00 63 00 00 00 00 } condition: $AES_KEY_MARKER }\u0026#34;\u0026#34;\u0026#34; } Đoạn code detect AES Key và IV, agent ID như sau:\nrules = yara.compile(sources = signatures) .... for offset, rule_name, _name, _value in layer.scan(context = self.context, scanner = yarascan.YaraScanner(rules = rules), sections = vadyarascan.VadYaraScan.get_vad_maps(proc)): if rule_name == \u0026#39;havoc_aes_marker\u0026#39;: # Read 1024 bytes from the layer at the offset and try to parse out some values. raw_data = layer.read(offset, 1024, False) vollog.debug(f\u0026#39;Found AES Key Marker at {hex(offset)} in {process_name}\\n\u0026#39;) vollog.debug(f\u0026#39;Raw Data: {raw_data}\\n\u0026#39;) agent_id = raw_data[8:12].hex() vollog.debug(f\u0026#39;Agent ID: {agent_id}\\n\u0026#39;) aes_key = raw_data[20:52].hex() vollog.debug(f\u0026#39;AES Key: {aes_key}\\n\u0026#39;) aes_iv = raw_data[52:68].hex() vollog.debug(f\u0026#39;AES IV: {aes_iv}\\n\u0026#39;) Có thể thấy AES Key ở offset [20:52], AES IV ở offset [52:68] và Agent ID ở [8:12] tại vị trí tìm ra signature.\nDo đó, mình nhanh chóng thu được key, iv và agent id từ file dump process.\nNhư vậy:\nThu được:\nagent id: 2a c0 84 1e aes key: [20:52] D4 DC 20 98 7E EC 20 02 E0 46 D0 D0 3C BC C2 9A 88 96 44 34 D0 42 90 12 66 BA 98 1C E0 48 98 1E aes iv: [52:68] DC DA C0 90 F6 5E A6 76 FC 72 8E 08 54 66 40 30 Như vậy, mình đã nghĩ đến đây là xong. Mình chỉ mất khoảng 1 tiếng để tìm được đến đây.\nVới bài phân tích vừa rồi, mình đoán sẽ dùng AES decrypt giải mã pcapng để lấy flag.\nTuy nhiên, mọi chuyện không như là mơ.\n2. Xử lý pcapng Kiểm tra pcapng thì chỉ thấy có 2 IP 192.168.240.148 và 192.168.240.147.\nKiểm tra thì chỉ có 2 tcpstream là 0 và 1. là các request đến cổng 443 của IP:148. (attacker)\nNhư vậy, mình cần tìm các requests gửi dữ liệu lên máy chủ, decrypt là lấy được file.\nKhó khăn từ đây (do mình dốt crypto :\u0026lt;)\nKiểm tra sơ sơ thì thấy có vài request POST send data rất lớn.\nĐến đây mình dùng Cyberchef để cố decrypt phần body request nhưng thử với tất cả các thuật toán đều không được, về sau phát hiện ra, Havoc dùng AES CTR mode.\nTuy nhiên, mình vẫn không decrypt được, mình có thử viết code python decrypt cũng không được. Mãi sau, mình mới đọc lại blog 51cto ở trên. Phát hiện phần body có cấu trúc. 20bytes đầu là các giá trị, sau đó là data bị mã hoá.\nData POST lên có cấu trúc như sau:\nDó, lúc này mình mới nhận ra và bắt đầu đi lọc các POST request lớn, có Agent ID và check dữ liệu decrypt.\nMình thu được output command, khẳng định AES Key IV là đúng\nSau đó mình tìm thấy một request có data decrypt có thứ rất quen thuộc, .rels và .xml. Với bản năng của 1 mal analysis, đây là docx mình cần!!!\nMình thu được file docx sau khi chạy word recovery.\nflag 2:\nFlag2: Th3_9r0unD_0b3y5_m3_0e2845b20c93546} Mình bắt đầu hơi hụt hẫng, ủa flag1 đâu, hay trong request vẫn còn. Mình tiếp tục đi decrypt hết các POST data, thậm chí cả data trả về của Havoc C2 server ở IP:148.\nThu được, đoạn text flagpart1 ????\nHay một số data có cấu trúc rất lạ, giống kiểu output của ascii graphic, mà mình không đoán ra ý nghĩa\nData ec0 ec1 do server gửi đến\nNohope flag part 1 :\u0026lt;\nSau đó team có tìm thêm 1 số string trong file OneDrive.exe\nNhưng có vẻ không khả quan lắm.\nCuối cùng mình định tạo lại lab Havoc nhưng đã quá muộn.\nEND GAME lần xxx :((((\nBonus, phần flagpart1, sau khi có WU của tác giả\nĐúng như dự đoán, phần dữ liệu được server gửi đến máy nạn nhân sẽ là 1 object BOF để thực thi,\nHãy quan sát 1 response\nNhư trên, khi server response theo cấu trúc chunk, ta sẽ chỉ quan tâm phần Chunk data.\nphần Chunk Data này sẽ cấu trúc như sau:\n12 bytes đầu (HEADER) | Sau là data Trong HEADER: 2 bytes đầu là Command ID (ở Little edians) =\u0026gt; 0x0A00 = 2560 =\u0026gt; BOF objects Như vậy, decrypt ra sẽ được BOF object.\nTuy nhiên, BOF có signature là bắt đầu bằng bytes\n0x64 0x86 cho 64 bit và 0x4C 0x01 (chữ dt và L.) như ảnh (Phần File Header của NTHeader)\nvới 32bit\nThì trong BOF sẽ như này\nNém vào IDA, phân tích, bấm mặc định, nó sẽ ra được\nNhư vậy, sau khi decrypt BOF bằng AES-CTR mode, ta sẽ phải xoá đi 16bytes đầu để bắt đầu bằng signature BOF.\nKiểm tra hết các BOF, thấy có BOF để thực thi adduser mà không cần dùng command adduser của windows. Đó là user flagpart1\nVì vậy, ta cần đi tìm data của câu lệnh này ở đâu trong BOF object này.\nPhần ảo: Tìm data của BOF object này Theo cấu trúc của havoc C2 BOF, thì các BOF sẽ được tạo sẵn , phần data sẽ nối ở phía sau BOF.\nNhưng các thức chúng được mã hoá AES lại khác nhau\nnhư sau:\nDataChunk = 12bytes HEADER + AES-CTF_Encrypt( 16bytes + BOF object ) + DATA_sau_BOF Mở rộng nhanh, thực tế phần data sau BOF object có 12 bytes là: TaskID, Command,Executable, packed data length nên: DATA_sau_BOF = 12 bytes + AES-CTF_Encrypt( Dữ liệu parametter của BOF ) Nghĩa phần data được mã hoá riêng rẽ chứ không mã hoá chung 1 lần với BOF object.\nMà AES-CTR mode sẽ mã hoá 1bytes thành 1 bytes (tương đương)\nNên chỉ cần lấy độ dài dữ liệu của data chunk post - độ dài BOF objects sau giải mã - 16bytes đầu\nsẽ ra được độ dài phần data bị mã hoá.\nVậy làm sao biết đc BOF object dài bao nhiêu.\nhttps://github.com/HavocFramework/Modules/blob/main/RemoteOps/bin/adduser.x64.o\nCác BOF object là pre-built\nVì vậy, chỉ cần tải file adduser.x64.o cho khớp với BOF trong decrypted data, ta sẽ có được length.\nỞ đây, object BOF Adduser kết thúc ở length 3583, tận cùng là byte 0x00\nVì vậy, với phần data encrypted ở Data chunk\nPhần này cấu trúc như đã nói, toàn bộ Data Chunk có length 3776.\nXoá 12bytes đầu header Được BOF encrypted + data encrypted Tuy nhiên BOF encrypted này có chứa 16bytes đầu là bytes gì đó, trước khi đến được đoạn signature BOF.\nXoá 16bytes đầu của BOF để ra đc signature dt\nXoá tiếp 3583 bytes BOF object\nTa thu được phần data BOF encrypted.\nTuy nhiên, phần data BOF encrypted này cũng có cấu trúc là 12 bytes: TaskID, Command,Executable, packed data length rồi mới đến AES-CTR_Encrypted(Data của BOF)\nXoá 12 bytes đầu\nThực hiện decrypt AES-CTR, Decode UTF-16 LE\nThu được đoạn bytes (153 bytes):\n3b 53 9a a6 93 b6 31 3a cf 25 d6 fa bd b3 ac 98 69 84 ad 7b 25 94 0e ab 5c 3c ec 4b da ea 98 e8 5e b5 c2 5a 8e 37 fa f8 83 eb c4 34 c4 d2 9c e0 67 a6 b5 c0 a3 98 57 3e 29 35 f9 aa 5d 25 1d 44 4d 3e 8d 15 f8 a0 ba 5b 12 a5 55 55 f4 d9 d4 85 b7 f4 1d 6d 8d 7b 4a b9 b0 ca 3e 4d 7b 45 75 4d ff fd 43 74 34 28 b9 d4 3e 14 1b b3 df 7b b6 7a 3c 86 23 7f 82 12 04 a7 5e 62 14 00 00 00 13 d0 c5 8f 13 00 00 00 64 09 97 a7 9e d9 31 8d f7 fd 4d a6 8d be ad 98 0f 84 ad Decrypt bằng AES-CTR và Decode UTF-16 LE:\nVậy flag1 :\nASCIS{C@nt_k3Ep_m3_1n_7hE_9r0uNd_ ","permalink":"https://qynklee.github.io/posts/ascis-2024-forensics-chall-thugs-on-the-boat/","summary":"\u003cp\u003eDưới đây là chall Forensic của SVATTT 2024. Tác giả: bquanman\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20241019215932448\" loading=\"lazy\" src=\"../ascis-2024-forensics-chall-Thugs-on-the-boat_img/image-20241019215932448.png\"\u003e\u003c/p\u003e\n\u003cp\u003eChall cho ta 2 file:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efile process dump\u003c/li\u003e\n\u003cli\u003efile pcapng lưu lượng mạng\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"1-kiểm-tra-file-process-dump\"\u003e1. Kiểm tra file process dump\u003c/h4\u003e\n\u003cp\u003eLoad vào windbg\u003c/p\u003e\n\u003cp\u003eDùng command \u003ccode\u003elm\u003c/code\u003e để check các module:\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20241019220138144\" loading=\"lazy\" src=\"../ascis-2024-forensics-chall-Thugs-on-the-boat_img/image-20241019220138144.png\"\u003e\u003c/p\u003e\n\u003cp\u003eNhận thấy chỉ có module OneDrive là không có symbols.\u003c/p\u003e\n\u003cp\u003eKiểm tra module này, bằng lệnh \u003ccode\u003elmDvmOneDrive\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20241019220239946\" loading=\"lazy\" src=\"../ascis-2024-forensics-chall-Thugs-on-the-boat_img/image-20241019220239946.png\"\u003e\u003c/p\u003e\n\u003cp\u003eThấy file thực thi được tải về từ Internet tại Downloads.\u003c/p\u003e","title":"ASCIS 2024 Forensics Chall: Thugs on the boat"},{"content":"Trong bài này mình sẽ phân tích một mẫu redline stealer được được thực thi thông qua file batch script có mã hash:\n4F1DD4357574C51EC7871212DBC7439C1013561041B5D6B3D5E5CE0DAC996AEB\nĐã quá lâu kể từ khi mình viết report phân tích vì\u0026hellip;.mình khá lười :smile:\nOk, lẹt gô\nStage 1 Đầu tiên với file batch script như sau:\nỞ đây các bạn có thể tấy echo off và line 6 cực kỳ dài. Line 6 bắt đầu bằng :: (tương đương lệnh REM) thì giống như nó đang truyền param là string tại line 6 vào 1 hàm nào đó đúng không. Đến đoạn này thì đầu tiên mình nghĩ đến dùng cmd deobfuscate tuy nhiên tool có vẻ không dùng được với đoạn này. Đến đây mình quyết định tham khảo công nghệ ChatGPT 3.5 (do nghèo) thì nhận được kết quả đoạn script đầu tiên là làm rối đoạn code check AV Defender. :\u0026lt;\nRồi, qua any.run có thể thấy sample này sau khi thực thi sẽ gọi đến cmd với một command khác, rõ ràng hơn, do vậy mình đã bỏ qua đoạn script này mà check luôn đoạn sau.\nCommand đoạn sau như sau: Thực hiện một hồi deobfuscate bằng cơm thì mình được đoạn sau:\nCó thể thấy là đoạn code trên đọc lại file bat ban đầu sau đó thực hiện decrypt và decompress gzip dể tạo 2 object [byte[]] sau đó thực hiện Assembly load 2 object này và thực thi.\nOK vậy là xong stage1.\nVậy thì dump 2 object này ra rồi phân tích thôi, comment đoạn Invoke cuối, save object bằng đoạn:\n$type = $PE_1.GetType() Write-Host \u0026#34;Variable type: $type\u0026#34; $filePath = \u0026#34;C:\\Users\\Inferno\\Desktop\\Malware\\PE_01.bin\u0026#34; [System.IO.File]::WriteAllBytes($filePath, [byte[]]$PE_1) $filePath = \u0026#34;C:\\Users\\Inferno\\Desktop\\Malware\\PE_02.bin\u0026#34; [System.IO.File]::WriteAllBytes($filePath, [byte[]]$PE_2) Stage 2 PE_2 được thực thi trước PE_1 trong code của script nên mình sẽ coi PE_2 trước.\nPE_2 là binary .Net, code cơ bản như sau:\nĐây là đoạn code thực hiện patchi AMSI + ETW của NetLoader để thực hiện load C# binary lên mem và thực thi. PE_2 chỉ có vậy.\nTiếp tục với PE_1\nVới sự đơn giản của PE_2 hứa hẹn PE_1 sẽ khá to và nhiều trò.\nPE_2 có code chính như sau:\nĐoạn code của PE_@ khá ngắn gọn, đơn giản:\nCheck debug Thực hiện Assembyload từ Resource \u0026ldquo;P\u0026rdquo; Đi dump resource P, ta thu được 1 binary C# tiếp theo.\nStage3: Phân tích resource P\nResource P được dump ra đc compress Gzip, extract thu được binary .Net:\ndnspy tiếp, lần này code đã nhiều hơn\nTại entrypoint khởi tạo form1, chỉ thấy các đoạn code tạo giao diện??? Nhìn kỹ chút ngay đầu có hàm Program.WriteLine() đầy nghi hoặc. Check hàm WriteLine thì đó chính là hàm thực thi malicious code:\nĐầu tiên, thực hiện EnvironmentChecker.Check()\nKiểm tra hàm này:\nThực hiện kiểm tra region của máy nạn nhân, nếu region nằm trong list RegionsCountry thì chương trình sẽ tắt:\nprivate static readonly string[] RegionsCountry = new string[] { \u0026#34;Armenia\u0026#34;, \u0026#34;Azerbaijan\u0026#34;, \u0026#34;Belarus\u0026#34;, \u0026#34;Kazakhstan\u0026#34;, \u0026#34;Kyrgyzstan\u0026#34;, \u0026#34;Moldova\u0026#34;, \u0026#34;Tajikistan\u0026#34;, \u0026#34;Uzbekistan\u0026#34;, \u0026#34;Ukraine\u0026#34;, \u0026#34;Russia\u0026#34; }; Ờ thì, list rõ ràng ghê á :v\nTiếp tục, mã độc thực hiện cài đặt RootCert và tìm tất cả shortcut của các trình duyệt và thêm \u0026ldquo;\u0026ndash;proxy-server=\u0026quot;217.65.2.14:3333\u0026quot;\u0026rdquo; để cài đặt proxy cho tất cả các trình duyệt. Điều này sẽ khiến toàn bộ lưu lượng của browser qua Proxy server của hacker, và được decrypt luôn tại có rootcert :\u0026lt; Tệ voãi ò.\nTiếp tục:\nTại hàm này sẽ thực hiện gọi các element của stealer, đồng thời giải mã IP, Port của CC server.\nThuật toán giải mã khá đơn giản:\nChỉ cần base64 \u0026gt; XOR key \u0026gt; base64 lại.\nIP = \u0026ldquo;GSY0Gz4JP1g8HhEILD1HGj8tHw4bJigZPQRPVA==\u0026rdquo;;\nKey = \u0026ldquo;Transcript\u0026rdquo;;\nDùng CyberChef, thu được IP:Port CC như sau:\nCC: 15.235.131.20:39206\nCheck tiếp hàm tạo kết nối đến CC, ta thu được thông tin Authen và rootCert được install vào máy nạn nhân.\nstring text = \u0026#34;0c859af6b9c95799f32f6a1659b784d6\u0026#34;; MessageHeader messageHeader = MessageHeader.CreateHeader(\u0026#34;Authorization\u0026#34;, \u0026#34;ns1\u0026#34;, text); Còn lại là các hàm thực hiện stealer :3 Mình sẽ không nói thêm ở đây. vì mình lười dồi :D\n","permalink":"https://qynklee.github.io/posts/analysis-a-redlinestealer-sample/","summary":"\u003cp\u003eTrong bài này mình sẽ phân tích một mẫu redline stealer được được thực thi thông qua file batch script có mã hash:\u003c/p\u003e\n\u003cp\u003e4F1DD4357574C51EC7871212DBC7439C1013561041B5D6B3D5E5CE0DAC996AEB\u003c/p\u003e\n\u003cp\u003eĐã quá lâu kể từ khi mình viết report phân tích vì\u0026hellip;.mình khá lười :smile:\u003c/p\u003e\n\u003cp\u003eOk, lẹt gô\u003c/p\u003e\n\u003ch3 id=\"stage-1\"\u003eStage 1\u003c/h3\u003e\n\u003cp\u003eĐầu tiên với file batch script như sau:\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20240402080214477\" loading=\"lazy\" src=\"../Analysis-a-RedlineStealer-sample_img/image-20240402080214477.png\"\u003e\u003c/p\u003e\n\u003cp\u003eỞ đây các bạn có thể tấy echo off và line 6 cực kỳ dài. Line 6 bắt đầu bằng :: (tương đương lệnh REM) thì giống như nó đang truyền param là string tại line 6 vào 1 hàm nào đó đúng không.\nĐến đoạn này thì đầu tiên mình nghĩ đến dùng cmd deobfuscate tuy nhiên tool có vẻ không dùng được với đoạn này.\nĐến đây mình quyết định tham khảo công nghệ ChatGPT 3.5 (do nghèo) thì nhận được kết quả đoạn script đầu tiên là làm rối đoạn code check AV Defender. :\u0026lt;\u003c/p\u003e","title":"Analysis a RedlineStealer Sample"}]