<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Analysis a Emotet Malware Sample | Qynklee in the wild</title>
<meta name="keywords" content="RE, Malware">
<meta name="description" content="
Giới thiệu

Mã độc Emotet là một trong những loại mã độc phổ biến nhất hiện nay, với nhiều biến thể, phiên bản cũ mới khác nhau nhưng nhìn chung mã độc này vẫn sử dụng cách thức lây nhiễm bằng việc spam email bằng những tài liệu được đính kèm macro mã độc.
Trong báo cáo này, tôi thực hiện phân tích mã độc Emotet E4 xuất hiện vào những ngày đầu tháng 12/2021. Biến thể này có sự thay đổi nhiều hơn hẳn so với mã độc Emotet lần đầu xuất hiện năm 2014 và có sự tương đồng ở một số điểm so với các biến thể E2, E3 đã xuất hiện trong năm 2021.">
<meta name="author" content="Qynklee">
<link rel="canonical" href="https://qynklee.github.io/posts/analysis-a-emotet-malware-sample/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://qynklee.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://qynklee.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://qynklee.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://qynklee.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://qynklee.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://qynklee.github.io/posts/analysis-a-emotet-malware-sample/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://qynklee.github.io/posts/analysis-a-emotet-malware-sample/">
  <meta property="og:site_name" content="Qynklee in the wild">
  <meta property="og:title" content="Analysis a Emotet Malware Sample">
  <meta property="og:description" content=" Giới thiệu Mã độc Emotet là một trong những loại mã độc phổ biến nhất hiện nay, với nhiều biến thể, phiên bản cũ mới khác nhau nhưng nhìn chung mã độc này vẫn sử dụng cách thức lây nhiễm bằng việc spam email bằng những tài liệu được đính kèm macro mã độc.
Trong báo cáo này, tôi thực hiện phân tích mã độc Emotet E4 xuất hiện vào những ngày đầu tháng 12/2021. Biến thể này có sự thay đổi nhiều hơn hẳn so với mã độc Emotet lần đầu xuất hiện năm 2014 và có sự tương đồng ở một số điểm so với các biến thể E2, E3 đã xuất hiện trong năm 2021.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-01-20T20:17:35+07:00">
    <meta property="article:modified_time" content="2022-01-20T20:17:35+07:00">
    <meta property="article:tag" content="RE">
    <meta property="article:tag" content="Malware">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Analysis a Emotet Malware Sample">
<meta name="twitter:description" content="
Giới thiệu

Mã độc Emotet là một trong những loại mã độc phổ biến nhất hiện nay, với nhiều biến thể, phiên bản cũ mới khác nhau nhưng nhìn chung mã độc này vẫn sử dụng cách thức lây nhiễm bằng việc spam email bằng những tài liệu được đính kèm macro mã độc.
Trong báo cáo này, tôi thực hiện phân tích mã độc Emotet E4 xuất hiện vào những ngày đầu tháng 12/2021. Biến thể này có sự thay đổi nhiều hơn hẳn so với mã độc Emotet lần đầu xuất hiện năm 2014 và có sự tương đồng ở một số điểm so với các biến thể E2, E3 đã xuất hiện trong năm 2021.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://qynklee.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Analysis a Emotet Malware Sample",
      "item": "https://qynklee.github.io/posts/analysis-a-emotet-malware-sample/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Analysis a Emotet Malware Sample",
  "name": "Analysis a Emotet Malware Sample",
  "description": " Giới thiệu Mã độc Emotet là một trong những loại mã độc phổ biến nhất hiện nay, với nhiều biến thể, phiên bản cũ mới khác nhau nhưng nhìn chung mã độc này vẫn sử dụng cách thức lây nhiễm bằng việc spam email bằng những tài liệu được đính kèm macro mã độc.\nTrong báo cáo này, tôi thực hiện phân tích mã độc Emotet E4 xuất hiện vào những ngày đầu tháng 12/2021. Biến thể này có sự thay đổi nhiều hơn hẳn so với mã độc Emotet lần đầu xuất hiện năm 2014 và có sự tương đồng ở một số điểm so với các biến thể E2, E3 đã xuất hiện trong năm 2021.\n",
  "keywords": [
    "RE", "Malware"
  ],
  "articleBody": " Giới thiệu Mã độc Emotet là một trong những loại mã độc phổ biến nhất hiện nay, với nhiều biến thể, phiên bản cũ mới khác nhau nhưng nhìn chung mã độc này vẫn sử dụng cách thức lây nhiễm bằng việc spam email bằng những tài liệu được đính kèm macro mã độc.\nTrong báo cáo này, tôi thực hiện phân tích mã độc Emotet E4 xuất hiện vào những ngày đầu tháng 12/2021. Biến thể này có sự thay đổi nhiều hơn hẳn so với mã độc Emotet lần đầu xuất hiện năm 2014 và có sự tương đồng ở một số điểm so với các biến thể E2, E3 đã xuất hiện trong năm 2021.\nMẫu sample được sử dụng trong bài có mã hash:\n67094b85f667eb916255162ddc1e974b093a133ef873be9ee60bf1a7ce030e9e\nTiến hành phân tích Sample là một file word Sample này có cách thực thi là lừa người dùng enable macro để script có thể được thực thi.\nKiểm tra với OleID xác nhận file có chứa macro VBA:\nVới olevba, ta thu được một số kết quả cho thấy file có thể tự thực thi thông qua hàm Document_close() và file có thực hiện thao tác với DLL.\nDump các macro ra với oledump thu được 3 file có liên quan đến macro\nHàm document_close()\nTrong hàm document_close() thực hiện gọi đến 1 hàm user define:\nKiểm tra hàm đó, nhận thấy hàm đã bị obfuscate đi khá nhiều nhưng ta vẫn có thể nhận ra luồng thực hiện của file là thực hiện tạo ra 1 string và gọi 1 hàm\nFind theo tên hàm Sgfrjoifhdolkibhonjduftgi\nTa thấy đây chính là hàm WinExec.\nKiểm tra bằng cách find các string tên các hàm được import từ user32 lib thì ta thấy đây chỉ là các hàm được khai báo mà không sử dụng, chỉ có hàm Sgfrjoifhdolkibhonjduftgi (WinExec) là hàm thực sự được dùng.\nĐọc ngược lại lời gọi đến WinExec để tìm đối số được truyền vào, nhận thấy nó thực hiện việc đọc 1 bảng từ object.\nNhư vậy nghĩa là trong file word còn chứa 1 số bảng đã bị ẩn, object…\nCũng như để tiện cho việc phân tích, thực hiện mở file bằng word để kiểm tra chi tiết hơn.\nTuy nhiên, vba project đã bị đặt mật khẩu\nĐể bypass mật khẩu, ta cần thực hiện patch byte DPB thành DPX trong vbProject.bin và tạo lại mật khẩu để file không bị lỗi.\nSau khi bypass được mật khẩu, ta có thể xem đầy đủ được VB Project này.\nTại đây, thực hiện view object của đối tượng vnbiu…\nWord trỏ đến 1 vùng trắng, thực hiện Unhide, đổi màu, hiện border cho bảng ta thu được:\nKhi đã có đủ các dữ kiện, ta đọc kỹ lại đoạn code ở hàm gọi WinExec\nĐầu tiên, hàm này lấy đoạn text ở Cell(3,1) lưu vào Object.Tag, đặt TextBox4 = “wgjaB “ và đặt TextBox2 là đoạn text ở Cell(2,1) + VBCRLF + đoạn text ở Cell(4,1)\nSau đó thực hiện mở file lưu ở Object.Tag và ghi nội dung ở TextBox2 vào đó.\nSau đó thực hiện WinExec file có tên lưu ở Object.Tag.\nCăn cứ vào đây, ta có thể thấy file bị thực thi đó chính là file “c:\\programdata\\yksds.bat”\nCó nội dung như sau:\nĐây là một đoạn code batch file đã bị obfuscate, mình đi thực hiện deobfuscate nó để xem nó thực sự là gì:\nTiếp tục thực hiện decode Base64 unicode ta thu được\nTại đây script powershell thực hiện tải file vể từ 1 trong các link cho sẵn đến khi nhận được file và lưu thành file .dll tại ProgramData.\nSau đó dùng rundll32.exe để load dll.\nĐến đây ta tiếp tục tải file dll này về để thực hiện phân tích.\nPhân tích dll được tải về File dll được tải về có mã hash:\nabb52688f65425072a2222fe0079879f15672890c1a272193868d3e02e52e760\nDLL chỉ import duy nhất kernel32.dll\nDll export\nKiểm tra các string của file dll phát hiện 2 string khá đáng ngờ là IsProcessorFeaturePresent và GetProcAddress\nPhân tích với IDA\nDll có áp dụng kỹ thuật AntiDebug\nBypass Antidebug và thực hiện debug file, phát hiện mã đọc thực hiện VirtualAlloc một vùng nhớ và memcpy đến vùng nhớ đó. Ngoài ra, với việc chỉ import kernel32.dll khiến rất có thể mã độc sẽ thực hiện LoadLibraryA. Vì vậy, ta đặt breakpoint tại các lệnh call như VirtualAlloc, memcpy, LoadLibraryA để kiểm tra.\nBreakpoint được trigger tại hàm VirtualAlloc.\nTiếp tục trace code ta thu được địa chỉ source và destination khi dll thực hiện memcpy.\nFollow theo địa chỉ source ta thu được một header PE rất quen thuộc\nTại đây, mã độc đang thực hiện load các section của dll tại source lên vùng nhớ tại ở địa chỉ 0x1000000 với Section Alignment là 0x1000.\nThực hiện dump vùng nhớ source bằng 1 script IDAPython nhỏ\nKiểm tra file đã dump ra, đây chính là 1 dll.\nVà lần này, file dll chỉ export duy nhất một hàm là DllRegisterServer. Và không có import bất kỳ Dll nào cũng như không có string nào có nghĩa.\nTiếp tục thực thi debug ta thấy dll gọi đến Entrypoint của dll mà ta vừa dump.\nPhân tích DLL vừa dump Phân tích với IDA ta có thể thấy hàm DllEntrypoint của dll được obfuscate.\nKiểm tra vào các hàm tiếp nhận thấy các hàm đều được obfuscate theo cùng một phương pháp là Control-Flow-Flatenning. Kỹ thuật này biến luồng thực thi nằm trong 1 vòng while(1) và switch case.\nVì vậy để đơn giản hóa việc phân tích ta sẽ chỉ cần bỏ qua hết các group chứa lệnh cmp, mov rồi jmp lại điểm đầu\nThực thi mã độc và ghi lại log với ProcMon và PinTool ta thu được\nDLL quả nhiên có load rất nhiều các dll khác nhau, đồng thời, sau đó tự copy chính mình vào local %AppData%.\nVà thêm khóa Registry để gọi chính mình.\nVới việc mã độc load rất nhiều dll, thực hiện thao tác ghi file, create registry… cho thấy mã độc đã áp dụng một số kỹ thuật của shellcode để có thể gọi được GetProcAddress và LoadLibraryA.\nKỹ thuật phổ biến trong trường hợp này là sử dụng cấu trúc PEB.\nTại đây, tôi sử dụng script IDAPython dưới đây để nhanh chóng tìm ra cấu trúc PEB.\nLập tức ta thu được địa chỉ trỏ đến một hàm\nTrace code theo Xref\nSau khi có được địa chỉ kernel32.dll, mã độc tiếp tục thực hiện việc tính hash string tên dll và tên hàm để thực hiện call function.\nDll thực hiện lấy địa chỉ các API dựa trên hash function:\nSau đó, dll thực hiện call API qua câu lệnh call EAX.\nSau quá trình phân tích, nhận thấy tất cả các hash function được push vào stack và gọi đến hàm STEP_5_GetFuncAddressInDLLImport và call eax để gọi đến hàm đó.\nNhư vậy, hàm STEP_5_ GetFuncAddressInDLLImport chính là chìa khóa để kiểm tra tất cả các API được gọi.\nKiểm tra Xref với hàm này, ta thu được rất nhiều function được gọi đến với các hash khác nhau.\nMột hàm gọi đến hàm STEP_5_GetFuncAddressInDLLImport\nĐi sâu vào phân tích hàm STEP_5_GetFuncAddressinDLLImport này ta tìm thấy hàm hash các string DLL và Function name được truyền vào.\nNgoài ra, cách hash này cũng được dùng để tính hash cho các dll name để tìm đúng mã hash được truyền vào.\nTiếp tục trace code trong hàm STEP_5_GetFuncAddressInDLLImport ta tìm được DLL xor key và function xor key\nDLL XOR key: 0x1BFA6646\nFunc XOR key: 0x3AACD9B2\nĐến đây ta có thể xây dựng lại toàn bộ quá trình tính hash để xác định được các hàm, API được gọi bằng việc brute force toàn bộ các Dll Name và Func Name.\nThử với một func ta thấy thuật toán hash tìm được hoàn toàn chính xác\nĐến đây, với các nguyên liệu đã có là mã hash đã biết, key xor, đầu vào chỉ là tên các dll và các tên hàm được export từ dll.\nThực hiện viết một script Python để lấy toàn bộ các export function từ các dll có liên quan và một script IDAPython để thực hiện xác định chính xác hàm nào, thuộc dll nào được gọi thông qua hàm STEP_5_GetFuncAddressInDLLImport.\nScript trên đây dùng để tạo dữ liệu gồm tên các dll và tên hàm được export.\nĐây là scrip IDAPython có nhiệm vụ kiểm tra tất cả các hàm Xref đến STEP_5_GetFuncAddressInDLLImport và lấy ra 2 giá trị DLL Hash và FuncHash để tìm tên chính xác và đổi tên hàm cho thuận tiện trong quá trình phân tích tiếp theo.\nKết quả sau khi chạy script ta thu được các tên hàm đã rất dễ hiểu hơn nhiều so với ban đầu\nDựa vào các dll được dynamic resolve là: advapi32, bcrypt, kernel32, shell32, shlwapi, userenv, wininet và wtsapi32 có thể thấy mã độc có thực hiện các thao tác đến Registry, thực hiện mã hóa, giải mã, kết nối mạng…\nVới câu hỏi, dll không hề có string khi kiểm tra string, làm cách làm lại có string của dll để thực hiện xor với hash. Tìm kiếm Xref đến hàm mw_kernel32_dll_LoadLibraryW mã ta vừa đổi tên phía trước. Ta thu được\nTa chỉ cần quan tâm đến thanh ghi esi sẽ nhận ra thanh ghi này được push làm tham số khi thực hiện call eax (call LoadLibraryW).\nNhư vậy chứng tỏ, bằng cách nào đó string bản rõ đã được giải mã ở esi.\nTiếp tục trace lên trên thấy: mov esi, eax\nĐiều này khẳng định string bản rõ được giải mã ở hàm call ngay phía trên.\nKiểm tra luồng thực thi của hàm này, ta thu được\nTrong hàm này đã gọi đến hàm HeapAlloc và GetProcessHeap. Điều này chứng tỏ đã có một vùng nhớ heap được tạo ra và rất có thể string bản rõ được giải mã lên heap.\nThực hiện debug hàm này với x64Dbg, ta xác thực việc này. String bản rõ được giải mã trên Heap là UTF-16 và sau khi Load được dll lên mã độc sẽ HeapFree vùng nhớ này ngay sau đó.\nĐể tìm được thuật toán giải mã string, ta đi kiểm tra sâu hơn hàm thực hiện HeapAlloc.\nMay mắn trong hàm này có thực hiện call nhưng chỉ liên quan đến call các API đã được đánh tên từ trước, vì vậy chắc chắn việc giải mã nằm ngay trong hàm này.\nKiểm tra các tham số đầu vào của hàm này, ta thấy hàm này được gọi từ rất nhiều vị trí nhưng đều có điểm chung.\nĐiểm chung đó là trước khi call được hàm này, mã độc sẽ push một offset vào ecx rồi mới thực hiện call.\nDựa vào đây ta có thể nhận định, dữ liệu được đưa vào ecx sau đó là edx rồi mới vào hàm thực hiện Decrypt.\nĐi tiếp vào trong hàm decrypt lúc trước, với edx đang chứa offset dữ liệu bị mã hóa, nó được mov sang esi. Và địa chỉ từ byte thứ 4 trở đi được mov sang edi.\nTừ đây, quá trình decrypt string trong esi và edi.\nCác bước thực hiện như sau:\nĐịa chỉ ban đầu esi Địa chỉ từ byte thứ 4 trở đi ở edi Giá trị eax = 2 lần giá trị ([edi] ^ [esi]) Khởi tạo Heap có độ dài bằng eax. Kết hợp với kết quả debug từ x64dbg phía trước ta xác định, giá trị [edi] ^ [esi] chính là độ dài string ở UTF-8, việc eax = 2 lần độ dài là do đó là string UTF-16.\nTiếp tục trace xuống vòng lặp phía dưới, lúc này EBX chứa địa chỉ vùng nhớ heap vừa được tạo.\nTừ đây ta có thể thấy, giải giải mã diễn ra bằng cách xor với key ở ebx, đây chính là 4 byte đầu của dữ liệu.\nTới đây ta đã có thuật toán mã hóa string và cách giải mã hoàn chỉnh. Dữ liệu về string được lưu có bố cục như sau:\nCác dữ liệu đã được mã hóa được lưu tại đoạn đầu section .text và IDA đã index được các đoạn này.\nThực hiện decrypt hết toàn bộ các dữ liệu này, sử dụng một script IDAPython để find các dword này và thực hiện decrypt, comment các dword này và log lại.\nKết quả thu được\nSau khi decrypt được toàn bộ các string ta có thể nhận ra một số string quan trọng như:\n0x71141000 SHA256\n0x71141020 ObjectLength\n0x71141040 Microsoft Primitive Provider\n0x71141080 ECCPUBLICBLOB\n0x711410b0 AES\n0x711410d0 HASH\n0x711410f0 ECDH_P256\n0x71141120 ECDSA_P256\n0x71141150 KeyDataBlob\nx71141504 POST\n0x71141514 __–%S–\n0x71141534 %u.%u.%u.%u\n0x71141564 Cookie: %s=%s__\n0x711415a4 Content-Type: multipart/form-data; boundary=%s__\n0x71141604 –%S__Content-Disposition: form-data; name=\"%S\"; filename=\"%S\"Content-Type: application/octet-stream\n0x71141684 %s%s.dll\n0x711416b4 %s%s.exe\n0x711416e4 DllRegisterServer\n0x71141714 %s\\regsvr32.exe -s “%s”\n0x71141754 %s\\rundll32.exe “%s”,DllRegisterServer\n0x71141794 %s\\rundll32.exe “%s”,DllRegisterServer %s\n0x711417d4 %s%s\n0x71141804 %s\\rundll32.exe “%s%s”,%s\n0x71141844 DllRegisterServer\n0x71141864 %s%s%x\n0x71141894 SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\n0x711418f4 %s\\rundll32.exe “%s%s”,%s %s\n0x71141934 %s\\rundll32.exe “%s”,DllRegisterServer\nDựa vào các string trên ta có thể thấy mã độc còn có mã hóa SHA256, AES và kết nối đến 1 IP, key registry mà mã độc sử dụng để autorun.\nDựa vào các string, các hàm đã recovery ta sẽ tiếp tục trace theo 2 hướng theo các hàm mã hóa từ dll bcrypt, string liên quan đến mã hóa và từ các hàm từ dll wininet.\nTrace theo string IP Format: %u.%u.%u.%u\nTại đây, offset của IP_Format được giải mã và lưu địa chỉ ở EAX, sau đó thực hiện call đến 1 sub_7114FFBA\nTìm theo hash value ta được hàm đó là _snwprintf(), dổi tên hàm lại cho đúng và bắt đầu phân tích hàm đã gọi đến offset IP_Format này.\nCũng giống như các hàm khác của mã độc, hàm này cũng đã bị obfuscate bằng phương pháp Control Flow Flatenning tuy nhiên với số lượng các khối khá ít hoàn toàn có thể phân tích luồng thực thi được.\nTại ngay điểm đầu vào, thực hiện cmp ecx, 0A5ACBAh do vậy thanh ghi ecx chính là thanh ghi dùng để điều khiển luồng thực thi.\nKéo lên trên để xem ecx đã được set giá trị bằng bao nhiêu, có thể thấy ngay đầu hàm, ecx đã được set giá trị\nNhư vậy, ta biết bước đầu tiên, sẽ thực thi khối nào\nTại đây ecx lại được mov một giá trị mới và cứ flow theo giá trị ecx, ta đến bước thứ 2\nTại bước thứ 2, mã độc thực hiện push offset một dword tại .data segment sau đó call đên sub_711602B3()\nKiểm tra trong hàm sub_711602B3() cho thấy hàm thực hiện tạo một vùng nhớ heap sau đó thực hiện một vòng loop rất quen thuộc tương đương như khi đang thực thi decrypt string.\nThực hiện dump dữ liệu ở vị trí này ra và decrypt bằng thuật toán đã dùng với string.\nTa thu được dữ liệu có cấu trúc gồm các giá trị, mỗi cụm 8 byte phân cách nhau bằng byte 0, 1.\nDebug với x64dbg khẳng định điều này, lần này dữ liệu giải mã ra cũng được HeapFree tại bước 6.\nNhư vậy chắc chắn trong hàm này có đoạn sử dụng đến dữ liệu đã decrypt ra. Đặt breakpoint tại vị trí này và thực thi, ta đến đoạn code sau:\nTại đây EDI đang lưu địa chỉ của dữ liệu vừa giải mã trên Heap.\nDebug với x64dbg, string format được giải mã và thực hiện hàm _snwprintf() với các tham số sau:\nKết quả thu được sau khi hàm _snwprintf() được thực thi\nNhư vậy 4 byte đầu trong cấu trúc 8 byte chính là địa chỉ IP.\nSau khi thực hiện giải mã IP ra Buffer, mã độc tiếp tục dùng thanh ghi edi đang trỏ đến dữ liệu đã giải mã trên heap để lấy ra giá trị word big endian tại byte thứ 5 và byte thứ 6. Đây chính là Port.\nTa thu được danh sách các CC Server như sau:\n[‘172.104.227.98:443’, ‘31.207.89.74:8080’, ‘46.55.222.11:443’, ‘41.76.108.46:8080’, ‘103.8.26.103:8080’, ‘185.184.25.237:8080’, ‘103.8.26.102:8080’, ‘203.114.109.124:443’, ‘45.118.115.99:8080’, ‘178.79.147.66:8080’, ‘58.227.42.236:80’, ‘45.118.135.203:7080’, ‘103.75.201.2:443’, ‘195.154.133.20:443’, ‘192.254.71.210:443’, ‘45.142.114.231:8080’, ‘212.237.5.209:443’, ‘207.38.84.195:8080’, ‘104.251.214.46:8080’, ‘212.237.17.99:8080’, ‘212.237.56.116:7080’, ‘216.158.226.206:443’, ‘110.232.117.186:8080’, ‘158.69.222.101:443’, ‘107.182.225.142:8080’, ‘176.104.106.96:8080’, ‘81.0.236.90:443’, ‘50.116.54.215:443’, ‘138.185.72.26:8080’, ‘51.68.175.8:8080’]\nTiếp tục phân tích theo các string đã thu được có string đặc biệt\n0x71141080 ECCPUBLICBLOB\n0x711410b0 AES\n0x711410d0 HASH\n0x711410f0 ECDH_P256\n0x71141120 ECDSA_P256\n0x71141150 KeyDataBlob\nĐây là các string của mã hóa ECC (Elliptic Curve Cryptography) là một kiểu mã hóa khóa công khai tương tự như RSA với khả năng mã hóa an toàn hơn với khóa ngắn hơn. Trong trường hợp của mã độc là P256 tức key 32bits.\nĐặc biệt hơn mã hóa ở đây chính là ECDH_P256 là thuật toán trao đổi khóa Diffie-Hellman ECC 256bit và ECDSA_P256 là thuật toán chữ ký số ECC 256bit.\nTrong quá trình giải mã các string của mã độc, có 2 string đã bị loại khỏi danh sách để add comment do chứa các byte không phải ký tự ascii tuy nhiên lại bắt đầu bằng “ECS1” và “ECK1”. Trong thư viện bcrypt.h có define:\nNhư vậy 2 string chứa các byte trên là khóa công khai của ECDSA và ECDH p256.\nĐể kiểm tra xem cụm byte trên có cấu trúc như thế nào, thực hiện debug với x64dbg trace code từ DllRegisterServer trở đi, ta đến được hàm call 71AB000D, tại đây thanh ghi ECX và EDX đang là con trỏ trở tới 2 cấu trúc ECS1 và ECK1.\nBên trong hàm sub_71AB000D thực hiện tạo heap và gọi đến sub_71AAE16F() hàm này gọi rất nhiều API đến từ thư viện bcrypt.\nBên trong sub_71AB000D():\nBên trong sub_71AAE16F():\nTiếp tục trace debug vào bên trong ta có thể thấy mã độc call:\nBCryptOpenAlgorithmProvider : ECDH_P256 Microsoft Primitive Provider BcryptGenerateKeyPair BcryptFinalizekeyPair: Handlekey 0x569AC8 BcryptExportKey với tham số ECCPUBLICBLOB. BcryptImportKeyPair BcryptSecretAgreement với Pubkey và PrivKey\npubKey:\nPrvKey\nTiếp tục trace debug qua x64dbg ta có thể thấy ngoài khởi tạo CNG Provider cho trao đổi khóa, mã độc còn khởi tạo CNG cho AES và SHA256. Tiếp tục dump ta sẽ nhận thấy các byte phía sau cảu cụm string ECK1 và ECS1 có cấu trúc như sau: Như vậy ta có thể khôi phục được khóa công khai mà mã độc sử dụng để mã hóa dữ liệu trong quá trình trao đổi key. Khóa thu được là: ",
  "wordCount" : "3099",
  "inLanguage": "en",
  "datePublished": "2022-01-20T20:17:35+07:00",
  "dateModified": "2022-01-20T20:17:35+07:00",
  "author":{
    "@type": "Person",
    "name": "Qynklee"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://qynklee.github.io/posts/analysis-a-emotet-malware-sample/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Qynklee in the wild",
    "logo": {
      "@type": "ImageObject",
      "url": "https://qynklee.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://qynklee.github.io/" accesskey="h" title="Qynklee in the wild (Alt + H)">Qynklee in the wild</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://qynklee.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://qynklee.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://qynklee.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://qynklee.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://qynklee.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://qynklee.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Analysis a Emotet Malware Sample
    </h1>
    <div class="post-meta"><span title='2022-01-20 20:17:35 +0700 +07'>January 20, 2022</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;3099 words&nbsp;·&nbsp;Qynklee

</div>
  </header> 

  <div class="post-content"><ol>
<li><strong>Giới thiệu</strong></li>
</ol>
<p>Mã độc Emotet là một trong những loại mã độc phổ biến nhất hiện nay, với nhiều biến thể, phiên bản cũ mới khác nhau nhưng nhìn chung mã độc này vẫn sử dụng cách thức lây nhiễm bằng việc spam email bằng những tài liệu được đính kèm macro mã độc.</p>
<p>Trong báo cáo này, tôi thực hiện phân tích mã độc Emotet E4 xuất hiện vào những ngày đầu tháng 12/2021. Biến thể này có sự thay đổi nhiều hơn hẳn so với mã độc Emotet lần đầu xuất hiện năm 2014 và có sự tương đồng ở một số điểm so với các biến thể E2, E3 đã xuất hiện trong năm 2021.</p>
<p>Mẫu sample được sử dụng trong bài có mã hash:</p>
<p>67094b85f667eb916255162ddc1e974b093a133ef873be9ee60bf1a7ce030e9e</p>
<ol>
<li><strong>Tiến hành phân tích</strong>
<ol>
<li><strong>Sample là một file word</strong></li>
</ol>
</li>
</ol>
<p><img alt="image1" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image1.png"></p>
<p>Sample này có cách thực thi là lừa người dùng enable macro để script có thể được thực thi.</p>
<p>Kiểm tra với OleID xác nhận file có chứa macro VBA:</p>
<p><img alt="image2" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image2.png"></p>
<p>Với olevba, ta thu được một số kết quả cho thấy file có thể tự thực thi thông qua hàm Document_close() và file có thực hiện thao tác với DLL.</p>
<p><img alt="image3" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image3.png"></p>
<p>Dump các macro ra với oledump thu được 3 file có liên quan đến macro</p>
<p><img alt="image4" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image4.png"><img alt="image5" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image5.png"><img alt="image6" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image6.png"></p>
<p>Hàm document_close()</p>
<p><img alt="image7" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image7.png"></p>
<p>Trong hàm document_close() thực hiện gọi đến 1 hàm user define:</p>
<p><img alt="image8" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image8.png"></p>
<p>Kiểm tra hàm đó, nhận thấy hàm đã bị obfuscate đi khá nhiều nhưng ta vẫn có thể nhận ra luồng thực hiện của file là thực hiện tạo ra 1 string và gọi 1 hàm</p>
<p><img alt="image9" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image9.png"></p>
<p>Find theo tên hàm Sgfrjoifhdolkibhonjduftgi</p>
<p>Ta thấy đây chính là hàm WinExec.</p>
<p><img alt="image10" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image10.png"></p>
<p>Kiểm tra bằng cách find các string tên các hàm được import từ user32 lib thì ta thấy đây chỉ là các hàm được khai báo mà không sử dụng, chỉ có hàm Sgfrjoifhdolkibhonjduftgi (WinExec) là hàm thực sự được dùng.</p>
<p><img alt="image11" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image11.png"><img alt="image12" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image12.png"></p>
<p>Đọc ngược lại lời gọi đến WinExec để tìm đối số được truyền vào, nhận thấy nó thực hiện việc đọc 1 bảng từ object.</p>
<p><img alt="image13" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image13.png"></p>
<p>Như vậy nghĩa là trong file word còn chứa 1 số bảng đã bị ẩn, object…</p>
<p>Cũng như để tiện cho việc phân tích, thực hiện mở file bằng word để kiểm tra chi tiết hơn.</p>
<p>Tuy nhiên, vba project đã bị đặt mật khẩu</p>
<p><img alt="image14" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image14.png"></p>
<p>Để bypass mật khẩu, ta cần thực hiện patch byte DPB thành DPX trong vbProject.bin và tạo lại mật khẩu để file không bị lỗi.</p>
<p>Sau khi bypass được mật khẩu, ta có thể xem đầy đủ được VB Project này.</p>
<p><img alt="image15" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image15.png"></p>
<p>Tại đây, thực hiện view object của đối tượng vnbiu…</p>
<p>Word trỏ đến 1 vùng trắng, thực hiện Unhide, đổi màu, hiện border cho bảng ta thu được:</p>
<p><img alt="image16" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image16.png"></p>
<p>Khi đã có đủ các dữ kiện, ta đọc kỹ lại đoạn code ở hàm gọi WinExec</p>
<p><img alt="image17" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image17.png"></p>
<p>Đầu tiên, hàm này lấy đoạn text ở Cell(3,1) lưu vào Object.Tag, đặt TextBox4 = “wgjaB “ và đặt TextBox2 là đoạn text ở Cell(2,1) + VBCRLF + đoạn text ở Cell(4,1)</p>
<p>Sau đó thực hiện mở file lưu ở Object.Tag và ghi nội dung ở TextBox2 vào đó.</p>
<p>Sau đó thực hiện WinExec file có tên lưu ở Object.Tag.</p>
<p>Căn cứ vào đây, ta có thể thấy file bị thực thi đó chính là file “c:\programdata\yksds.bat”</p>
<p>Có nội dung như sau:</p>
<p><img alt="image18" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image18.png"></p>
<p>Đây là một đoạn code batch file đã bị obfuscate, mình đi thực hiện deobfuscate nó để xem nó thực sự là gì:</p>
<p><img alt="image19" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image19.png"></p>
<p>Tiếp tục thực hiện decode Base64 unicode ta thu được</p>
<p><img alt="image20" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image20.png"></p>
<p>Tại đây script powershell thực hiện tải file vể từ 1 trong các link cho sẵn đến khi nhận được file và lưu thành file .dll tại ProgramData.</p>
<p>Sau đó dùng rundll32.exe để load dll.</p>
<p>Đến đây ta tiếp tục tải file dll này về để thực hiện phân tích.</p>
<ul>
<li>
<ol>
<li><strong>Phân tích dll được tải về</strong></li>
</ol>
</li>
</ul>
<p>File dll được tải về có mã hash:</p>
<p>abb52688f65425072a2222fe0079879f15672890c1a272193868d3e02e52e760</p>
<p><img alt="image21" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image21.png"></p>
<p>DLL chỉ import duy nhất kernel32.dll</p>
<p><img alt="image22" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image22.png"></p>
<p>Dll export</p>
<p><img alt="image23" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image23.png"></p>
<p>Kiểm tra các string của file dll phát hiện 2 string khá đáng ngờ là IsProcessorFeaturePresent và GetProcAddress</p>
<p><img alt="image24" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image24.png"></p>
<p>Phân tích với IDA</p>
<p>Dll có áp dụng kỹ thuật AntiDebug</p>
<p><img alt="image25" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image25.png"></p>
<p>Bypass Antidebug và thực hiện debug file, phát hiện mã đọc thực hiện VirtualAlloc một vùng nhớ và memcpy đến vùng nhớ đó. Ngoài ra, với việc chỉ import kernel32.dll khiến rất có thể mã độc sẽ thực hiện LoadLibraryA. Vì vậy, ta đặt breakpoint tại các lệnh call như VirtualAlloc, memcpy, LoadLibraryA để kiểm tra.</p>
<p>Breakpoint được trigger tại hàm VirtualAlloc.</p>
<p><img alt="image26" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image26.png"></p>
<p>Tiếp tục trace code ta thu được địa chỉ source và destination khi dll thực hiện memcpy.</p>
<p>Follow theo địa chỉ source ta thu được một header PE rất quen thuộc</p>
<p><img alt="image27" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image27.png"></p>
<p>Tại đây, mã độc đang thực hiện load các section của dll tại source lên vùng nhớ tại ở địa chỉ 0x1000000 với Section Alignment là 0x1000.</p>
<p>Thực hiện dump vùng nhớ source bằng 1 script IDAPython nhỏ</p>
<p><img alt="image28" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image28.png"></p>
<p>Kiểm tra file đã dump ra, đây chính là 1 dll.</p>
<p>Và lần này, file dll chỉ export duy nhất một hàm là DllRegisterServer. Và không có import bất kỳ Dll nào cũng như không có string nào có nghĩa.</p>
<p><img alt="image29" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image29.png"></p>
<p>Tiếp tục thực thi debug ta thấy dll gọi đến Entrypoint của dll mà ta vừa dump.</p>
<ul>
<li>
<ol>
<li><strong>Phân tích DLL vừa dump</strong></li>
</ol>
</li>
</ul>
<p>Phân tích với IDA ta có thể thấy hàm DllEntrypoint của dll được obfuscate.</p>
<p><img alt="image30" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image30.png"></p>
<p>Kiểm tra vào các hàm tiếp nhận thấy các hàm đều được obfuscate theo cùng một phương pháp là Control-Flow-Flatenning. Kỹ thuật này biến luồng thực thi nằm trong 1 vòng while(1) và switch case.</p>
<p>Vì vậy để đơn giản hóa việc phân tích ta sẽ chỉ cần bỏ qua hết các group chứa lệnh cmp, mov rồi jmp lại điểm đầu</p>
<p><img alt="image31" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image31.png"></p>
<p>Thực thi mã độc và ghi lại log với ProcMon và PinTool ta thu được</p>
<p><img alt="image32" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image32.png"></p>
<p>DLL quả nhiên có load rất nhiều các dll khác nhau, đồng thời, sau đó tự copy chính mình vào local %AppData%.</p>
<p><img alt="image33" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image33.png"></p>
<p>Và thêm khóa Registry để gọi chính mình.</p>
<p><img alt="image34" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image34.png"></p>
<p>Với việc mã độc load rất nhiều dll, thực hiện thao tác ghi file, create registry… cho thấy mã độc đã áp dụng một số kỹ thuật của shellcode để có thể gọi được GetProcAddress và LoadLibraryA.</p>
<p>Kỹ thuật phổ biến trong trường hợp này là sử dụng cấu trúc PEB.</p>
<p>Tại đây, tôi sử dụng script IDAPython dưới đây để nhanh chóng tìm ra cấu trúc PEB.</p>
<p><img alt="image35" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image35.png"></p>
<p>Lập tức ta thu được địa chỉ trỏ đến một hàm</p>
<p><img alt="image36" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image36.png"></p>
<p>Trace code theo Xref</p>
<p><img alt="image37" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image37.png"></p>
<p>Sau khi có được địa chỉ kernel32.dll, mã độc tiếp tục thực hiện việc tính hash string tên dll và tên hàm để thực hiện call function.</p>
<p>Dll thực hiện lấy địa chỉ các API dựa trên hash function:</p>
<p><img alt="image38" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image38.png"></p>
<p>Sau đó, dll thực hiện call API qua câu lệnh call EAX.</p>
<p><img alt="image39" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image39.png"></p>
<p>Sau quá trình phân tích, nhận thấy tất cả các hash function được push vào stack và gọi đến hàm STEP_5_GetFuncAddressInDLLImport và call eax để gọi đến hàm đó.</p>
<p>Như vậy, hàm STEP_5_ GetFuncAddressInDLLImport chính là chìa khóa để kiểm tra tất cả các API được gọi.</p>
<p>Kiểm tra Xref với hàm này, ta thu được rất nhiều function được gọi đến với các hash khác nhau.</p>
<p><img alt="image40" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image40.png"></p>
<p>Một hàm gọi đến hàm STEP_5_GetFuncAddressInDLLImport</p>
<p><img alt="image41" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image41.png"></p>
<p>Đi sâu vào phân tích hàm STEP_5_GetFuncAddressinDLLImport này ta tìm thấy hàm hash các string DLL và Function name được truyền vào.</p>
<p><img alt="image42" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image42.png"></p>
<p>Ngoài ra, cách hash này cũng được dùng để tính hash cho các dll name để tìm đúng mã hash được truyền vào.</p>
<p><img alt="image43" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image43.png"></p>
<p>Tiếp tục trace code trong hàm STEP_5_GetFuncAddressInDLLImport ta tìm được DLL xor key và function xor key</p>
<p>DLL XOR key: 0x1BFA6646</p>
<p><img alt="image44" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image44.png"></p>
<p>Func XOR key: 0x3AACD9B2</p>
<p><img alt="image45" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image45.png"></p>
<p>Đến đây ta có thể xây dựng lại toàn bộ quá trình tính hash để xác định được các hàm, API được gọi bằng việc brute force toàn bộ các Dll Name và Func Name.</p>
<p>Thử với một func ta thấy thuật toán hash tìm được hoàn toàn chính xác</p>
<p><img alt="image46" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image46.png"></p>
<p>Đến đây, với các nguyên liệu đã có là mã hash đã biết, key xor, đầu vào chỉ là tên các dll và các tên hàm được export từ dll.</p>
<p>Thực hiện viết một script Python để lấy toàn bộ các export function từ các dll có liên quan và một script IDAPython để thực hiện xác định chính xác hàm nào, thuộc dll nào được gọi thông qua hàm STEP_5_GetFuncAddressInDLLImport.</p>
<p><img alt="image47" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image47.png"></p>
<p>Script trên đây dùng để tạo dữ liệu gồm tên các dll và tên hàm được export.</p>
<p>Đây là scrip IDAPython có nhiệm vụ kiểm tra tất cả các hàm Xref đến STEP_5_GetFuncAddressInDLLImport và lấy ra 2 giá trị DLL Hash và FuncHash để tìm tên chính xác và đổi tên hàm cho thuận tiện trong quá trình phân tích tiếp theo.</p>
<p><img alt="image48" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image48.png"><img alt="image49" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image49.png"></p>
<p>Kết quả sau khi chạy script ta thu được các tên hàm đã rất dễ hiểu hơn nhiều so với ban đầu</p>
<p><img alt="image50" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image50.png"></p>
<p>Dựa vào các dll được dynamic resolve là: advapi32, bcrypt, kernel32, shell32, shlwapi, userenv, wininet và wtsapi32 có thể thấy mã độc có thực hiện các thao tác đến Registry, thực hiện mã hóa, giải mã, kết nối mạng…</p>
<p>Với câu hỏi, dll không hề có string khi kiểm tra string, làm cách làm lại có string của dll để thực hiện xor với hash. Tìm kiếm Xref đến hàm mw_kernel32_dll_LoadLibraryW mã ta vừa đổi tên phía trước. Ta thu được</p>
<p><img alt="image51" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image51.png"></p>
<p>Ta chỉ cần quan tâm đến thanh ghi esi sẽ nhận ra thanh ghi này được push làm tham số khi thực hiện call eax (call LoadLibraryW).</p>
<p>Như vậy chứng tỏ, bằng cách nào đó string bản rõ đã được giải mã ở esi.</p>
<p>Tiếp tục trace lên trên thấy: mov esi, eax</p>
<p>Điều này khẳng định string bản rõ được giải mã ở hàm call ngay phía trên.</p>
<p>Kiểm tra luồng thực thi của hàm này, ta thu được</p>
<p><img alt="image52" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image52.png"></p>
<p>Trong hàm này đã gọi đến hàm HeapAlloc và GetProcessHeap. Điều này chứng tỏ đã có một vùng nhớ heap được tạo ra và rất có thể string bản rõ được giải mã lên heap.</p>
<p>Thực hiện debug hàm này với x64Dbg, ta xác thực việc này. String bản rõ được giải mã trên Heap là UTF-16 và sau khi Load được dll lên mã độc sẽ HeapFree vùng nhớ này ngay sau đó.</p>
<p><img alt="image53" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image53.png"></p>
<p>Để tìm được thuật toán giải mã string, ta đi kiểm tra sâu hơn hàm thực hiện HeapAlloc.</p>
<p>May mắn trong hàm này có thực hiện call nhưng chỉ liên quan đến call các API đã được đánh tên từ trước, vì vậy chắc chắn việc giải mã nằm ngay trong hàm này.</p>
<p>Kiểm tra các tham số đầu vào của hàm này, ta thấy hàm này được gọi từ rất nhiều vị trí nhưng đều có điểm chung.</p>
<p><img alt="image54" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image54.png"></p>
<p>Điểm chung đó là trước khi call được hàm này, mã độc sẽ push một offset vào ecx rồi mới thực hiện call.</p>
<p><img alt="image55" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image55.png"></p>
<p>Dựa vào đây ta có thể nhận định, dữ liệu được đưa vào ecx sau đó là edx rồi mới vào hàm thực hiện Decrypt.</p>
<p><img alt="image56" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image56.png"></p>
<p>Đi tiếp vào trong hàm decrypt lúc trước, với edx đang chứa offset dữ liệu bị mã hóa, nó được mov sang esi. Và địa chỉ từ byte thứ 4 trở đi được mov sang edi.</p>
<p><img alt="image57" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image57.png"></p>
<p>Từ đây, quá trình decrypt string trong esi và edi.</p>
<p><img alt="image58" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image58.png"></p>
<p>Các bước thực hiện như sau:</p>
<ul>
<li>Địa chỉ ban đầu esi</li>
<li>Địa chỉ từ byte thứ 4 trở đi ở edi</li>
<li>Giá trị eax = 2 lần giá trị ([edi] ^ [esi])</li>
<li>Khởi tạo Heap có độ dài bằng eax.</li>
</ul>
<p>Kết hợp với kết quả debug từ x64dbg phía trước ta xác định, giá trị [edi] ^ [esi] chính là độ dài string ở UTF-8, việc eax = 2 lần độ dài là do đó là string UTF-16.</p>
<p>Tiếp tục trace xuống vòng lặp phía dưới, lúc này EBX chứa địa chỉ vùng nhớ heap vừa được tạo.</p>
<p><img alt="image59" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image59.png"></p>
<p>Từ đây ta có thể thấy, giải giải mã diễn ra bằng cách xor với key ở ebx, đây chính là 4 byte đầu của dữ liệu.</p>
<p>Tới đây ta đã có thuật toán mã hóa string và cách giải mã hoàn chỉnh. Dữ liệu về string được lưu có bố cục như sau:</p>
<p><img alt="image60" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image60.png"></p>
<p>Các dữ liệu đã được mã hóa được lưu tại đoạn đầu section .text và IDA đã index được các đoạn này.</p>
<p><img alt="image61" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image61.png"></p>
<p>Thực hiện decrypt hết toàn bộ các dữ liệu này, sử dụng một script IDAPython để find các dword này và thực hiện decrypt, comment các dword này và log lại.</p>
<p><img alt="image62" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image62.png"></p>
<p>Kết quả thu được</p>
<p><img alt="image63" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image63.png"></p>
<p>Sau khi decrypt được toàn bộ các string ta có thể nhận ra một số string quan trọng như:</p>
<p><em>0x71141000 SHA256</em></p>
<p><em>0x71141020 ObjectLength</em></p>
<p><em>0x71141040 Microsoft Primitive Provider</em></p>
<p><em>0x71141080 ECCPUBLICBLOB</em></p>
<p><em>0x711410b0 AES</em></p>
<p><em>0x711410d0 HASH</em></p>
<p><em>0x711410f0 ECDH_P256</em></p>
<p><em>0x71141120 ECDSA_P256</em></p>
<p><em>0x71141150 KeyDataBlob</em></p>
<p><em>x71141504 POST</em></p>
<p><em>0x71141514 __&ndash;%S&ndash;</em></p>
<p><em>0x71141534 %u.%u.%u.%u</em></p>
<p><em>0x71141564 Cookie: %s=%s__</em></p>
<p><em>0x711415a4 Content-Type: multipart/form-data; boundary=%s__</em></p>
<p><em>0x71141604 <strong>&ndash;%S__Content-Disposition: form-data; name=&quot;%S&quot;; filename=&quot;%S&quot;<strong>Content-Type: application/octet-stream</strong></strong></em></p>
<p><em>0x71141684 %s%s.dll</em></p>
<p><em>0x711416b4 %s%s.exe</em></p>
<p><em>0x711416e4 DllRegisterServer</em></p>
<p><em>0x71141714 %s\regsvr32.exe -s &ldquo;%s&rdquo;</em></p>
<p><em>0x71141754 %s\rundll32.exe &ldquo;%s&rdquo;,DllRegisterServer</em></p>
<p><em>0x71141794 %s\rundll32.exe &ldquo;%s&rdquo;,DllRegisterServer %s</em></p>
<p><em>0x711417d4 %s%s</em></p>
<p><em>0x71141804 %s\rundll32.exe &ldquo;%s%s&rdquo;,%s</em></p>
<p><em>0x71141844 DllRegisterServer</em></p>
<p><em>0x71141864 %s%s%x</em></p>
<p><em>0x71141894 SOFTWARE\Microsoft\Windows\CurrentVersion\Run</em></p>
<p><em>0x711418f4 %s\rundll32.exe &ldquo;%s%s&rdquo;,%s %s</em></p>
<p><em>0x71141934 %s\rundll32.exe &ldquo;%s&rdquo;,DllRegisterServer</em></p>
<p>Dựa vào các string trên ta có thể thấy mã độc còn có mã hóa SHA256, AES và kết nối đến 1 IP, key registry mà mã độc sử dụng để autorun.</p>
<p>Dựa vào các string, các hàm đã recovery ta sẽ tiếp tục trace theo 2 hướng theo các hàm mã hóa từ dll bcrypt, string liên quan đến mã hóa và từ các hàm từ dll wininet.</p>
<p>Trace theo string IP Format: %u.%u.%u.%u</p>
<p><img alt="image64" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image64.png"></p>
<p>Tại đây, offset của IP_Format được giải mã và lưu địa chỉ ở EAX, sau đó thực hiện call đến 1 sub_7114FFBA</p>
<p><img alt="image65" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image65.png"></p>
<p>Tìm theo hash value ta được hàm đó là _snwprintf(), dổi tên hàm lại cho đúng và bắt đầu phân tích hàm đã gọi đến offset IP_Format này.</p>
<p>Cũng giống như các hàm khác của mã độc, hàm này cũng đã bị obfuscate bằng phương pháp Control Flow Flatenning tuy nhiên với số lượng các khối khá ít hoàn toàn có thể phân tích luồng thực thi được.</p>
<p><img alt="image66" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image66.png"></p>
<p>Tại ngay điểm đầu vào, thực hiện cmp ecx, 0A5ACBAh do vậy thanh ghi ecx chính là thanh ghi dùng để điều khiển luồng thực thi.</p>
<p><img alt="image67" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image67.png"></p>
<p>Kéo lên trên để xem ecx đã được set giá trị bằng bao nhiêu, có thể thấy ngay đầu hàm, ecx đã được set giá trị</p>
<p><img alt="image68" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image68.png"></p>
<p>Như vậy, ta biết bước đầu tiên, sẽ thực thi khối nào</p>
<p><img alt="image69" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image69.png"></p>
<p>Tại đây ecx lại được mov một giá trị mới và cứ flow theo giá trị ecx, ta đến bước thứ 2</p>
<p><img alt="image70" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image70.png"></p>
<p>Tại bước thứ 2, mã độc thực hiện push offset một dword tại .data segment sau đó call đên sub_711602B3()</p>
<p>Kiểm tra trong hàm sub_711602B3() cho thấy hàm thực hiện tạo một vùng nhớ heap sau đó thực hiện một vòng loop rất quen thuộc tương đương như khi đang thực thi decrypt string.</p>
<p><img alt="image71" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image71.png"></p>
<p>Thực hiện dump dữ liệu ở vị trí này ra và decrypt bằng thuật toán đã dùng với string.</p>
<p><img alt="image72" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image72.png"></p>
<p>Ta thu được dữ liệu có cấu trúc gồm các giá trị, mỗi cụm 8 byte phân cách nhau bằng byte 0, 1.</p>
<p>Debug với x64dbg khẳng định điều này, lần này dữ liệu giải mã ra cũng được HeapFree tại bước 6.</p>
<p><img alt="image73" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image73.png"></p>
<p>Như vậy chắc chắn trong hàm này có đoạn sử dụng đến dữ liệu đã decrypt ra. Đặt breakpoint tại vị trí này và thực thi, ta đến đoạn code sau:</p>
<p><img alt="image74" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image74.png"></p>
<p>Tại đây EDI đang lưu địa chỉ của dữ liệu vừa giải mã trên Heap.</p>
<p>Debug với x64dbg, string format được giải mã và thực hiện hàm _snwprintf() với các tham số sau:</p>
<p><img alt="image75" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image75.png"></p>
<p>Kết quả thu được sau khi hàm _snwprintf() được thực thi</p>
<p><img alt="image76" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image76.png"></p>
<p>Như vậy 4 byte đầu trong cấu trúc 8 byte chính là địa chỉ IP.</p>
<p><img alt="image77" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image77.png"></p>
<p>Sau khi thực hiện giải mã IP ra Buffer, mã độc tiếp tục dùng thanh ghi edi đang trỏ đến dữ liệu đã giải mã trên heap để lấy ra giá trị word big endian tại byte thứ 5 và byte thứ 6. Đây chính là Port.</p>
<p>Ta thu được danh sách các CC Server như sau:</p>
<p><em>[&lsquo;172.104.227.98:443&rsquo;, &lsquo;31.207.89.74:8080&rsquo;, &lsquo;46.55.222.11:443&rsquo;, &lsquo;41.76.108.46:8080&rsquo;, &lsquo;103.8.26.103:8080&rsquo;, &lsquo;185.184.25.237:8080&rsquo;, &lsquo;103.8.26.102:8080&rsquo;, &lsquo;203.114.109.124:443&rsquo;, &lsquo;45.118.115.99:8080&rsquo;, &lsquo;178.79.147.66:8080&rsquo;, &lsquo;58.227.42.236:80&rsquo;, &lsquo;45.118.135.203:7080&rsquo;, &lsquo;103.75.201.2:443&rsquo;, &lsquo;195.154.133.20:443&rsquo;, &lsquo;192.254.71.210:443&rsquo;, &lsquo;45.142.114.231:8080&rsquo;, &lsquo;212.237.5.209:443&rsquo;, &lsquo;207.38.84.195:8080&rsquo;, &lsquo;104.251.214.46:8080&rsquo;, &lsquo;212.237.17.99:8080&rsquo;, &lsquo;212.237.56.116:7080&rsquo;, &lsquo;216.158.226.206:443&rsquo;, &lsquo;110.232.117.186:8080&rsquo;, &lsquo;158.69.222.101:443&rsquo;, &lsquo;107.182.225.142:8080&rsquo;, &lsquo;176.104.106.96:8080&rsquo;, &lsquo;81.0.236.90:443&rsquo;, &lsquo;50.116.54.215:443&rsquo;, &lsquo;138.185.72.26:8080&rsquo;, &lsquo;51.68.175.8:8080&rsquo;]</em></p>
<p>Tiếp tục phân tích theo các string đã thu được có string đặc biệt</p>
<p><em>0x71141080 ECCPUBLICBLOB</em></p>
<p><em>0x711410b0 AES</em></p>
<p><em>0x711410d0 HASH</em></p>
<p><em>0x711410f0 ECDH_P256</em></p>
<p><em>0x71141120 ECDSA_P256</em></p>
<p><em>0x71141150 KeyDataBlob</em></p>
<p>Đây là các string của mã hóa ECC (Elliptic Curve Cryptography) là một kiểu mã hóa khóa công khai tương tự như RSA với khả năng mã hóa an toàn hơn với khóa ngắn hơn. Trong trường hợp của mã độc là P256 tức key 32bits.</p>
<p>Đặc biệt hơn mã hóa ở đây chính là ECDH_P256 là thuật toán trao đổi khóa Diffie-Hellman ECC 256bit và ECDSA_P256 là thuật toán chữ ký số ECC 256bit.</p>
<p>Trong quá trình giải mã các string của mã độc, có 2 string đã bị loại khỏi danh sách để add comment do chứa các byte không phải ký tự ascii tuy nhiên lại bắt đầu bằng “ECS1” và “ECK1”. Trong thư viện bcrypt.h có define:</p>
<p><img alt="image78" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image78.png"></p>
<p>Như vậy 2 string chứa các byte trên là khóa công khai của ECDSA và ECDH p256.</p>
<p>Để kiểm tra xem cụm byte trên có cấu trúc như thế nào, thực hiện debug với x64dbg trace code từ DllRegisterServer trở đi, ta đến được hàm call 71AB000D, tại đây thanh ghi ECX và EDX đang là con trỏ trở tới 2 cấu trúc ECS1 và ECK1.</p>
<p><img alt="image79" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image79.png"></p>
<p>Bên trong hàm sub_71AB000D thực hiện tạo heap và gọi đến sub_71AAE16F() hàm này gọi rất nhiều API đến từ thư viện bcrypt.</p>
<p>Bên trong sub_71AB000D():</p>
<p><img alt="image80" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image80.png"></p>
<p>Bên trong sub_71AAE16F():</p>
<p><img alt="image81" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image81.png"></p>
<p>Tiếp tục trace debug vào bên trong ta có thể thấy mã độc call:</p>
<ul>
<li>BCryptOpenAlgorithmProvider : ECDH_P256 Microsoft Primitive Provider</li>
<li>BcryptGenerateKeyPair</li>
<li>BcryptFinalizekeyPair: Handlekey 0x569AC8</li>
</ul>
<p><img alt="image82" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image82.png"></p>
<ul>
<li>BcryptExportKey với tham số ECCPUBLICBLOB.</li>
</ul>
<p><img alt="image83" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image83.png"></p>
<ul>
<li>BcryptImportKeyPair</li>
</ul>
<p><img alt="image84" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image84.png"></p>
<ul>
<li>
<p>BcryptSecretAgreement với Pubkey và PrivKey</p>
<p>pubKey:</p>
<p>PrvKey</p>
</li>
</ul>
<p><img alt="image85" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image85.png"><img alt="image86" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image86.png"><img alt="image87" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image87.png"></p>
<ul>
<li>Tiếp tục trace debug qua x64dbg ta có thể thấy ngoài khởi tạo CNG Provider cho trao đổi khóa, mã độc còn khởi tạo CNG cho AES và SHA256.</li>
<li>Tiếp tục dump ta sẽ nhận thấy các byte phía sau cảu cụm string ECK1 và ECS1 có cấu trúc như sau:</li>
</ul>
<p><img alt="image88" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image88.png"></p>
<ul>
<li>Như vậy ta có thể khôi phục được khóa công khai mà mã độc sử dụng để mã hóa dữ liệu trong quá trình trao đổi key.</li>
</ul>
<p><img alt="image89" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image89.png"></p>
<ul>
<li>Khóa thu được là:</li>
</ul>
<p><img alt="image90" loading="lazy" src="../Analysis-a-Emotet-malware-sample_img/image90.png"></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://qynklee.github.io/tags/re/">RE</a></li>
      <li><a href="https://qynklee.github.io/tags/malware/">Malware</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://qynklee.github.io/posts/analysis-a-redlinestealer-sample/">
    <span class="title">« Prev</span>
    <br>
    <span>Analysis a RedlineStealer Sample</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://qynklee.github.io/">Qynklee in the wild</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
